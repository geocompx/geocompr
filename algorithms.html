<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 10 Scripts, algorithms and functions | Geocomputation with R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="Prerequisites This chapter primarily uses base R; the sf package is used to check the result of an algorithm we will develop. It assumes you have an understanding of the geographic classes...">
<meta name="generator" content="bookdown 0.24 with bs4_book()">
<meta property="og:title" content="Chapter 10 Scripts, algorithms and functions | Geocomputation with R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://geocompr.robinlovelace.net/algorithms.html">
<meta property="og:image" content="https://geocompr.robinlovelace.net/images/cover.png">
<meta property="og:description" content="Prerequisites This chapter primarily uses base R; the sf package is used to check the result of an algorithm we will develop. It assumes you have an understanding of the geographic classes...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 10 Scripts, algorithms and functions | Geocomputation with R">
<meta name="twitter:description" content="Prerequisites This chapter primarily uses base R; the sf package is used to check the result of an algorithm we will develop. It assumes you have an understanding of the geographic classes...">
<meta name="twitter:image" content="https://geocompr.robinlovelace.net/images/cover.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/header-attrs-2.11/header-attrs.js"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/_Lato-0.4.0/font.css" rel="stylesheet">
<link href="libs/_Roboto%20Mono-0.4.0/font.css" rel="stylesheet">
<link href="libs/_Montserrat-0.4.0/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.3.1/transition.js"></script><script src="libs/bs3compat-0.3.1/tabs.js"></script><script src="libs/bs3compat-0.3.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/htmlwidgets-1.5.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.0.4.1/leaflet.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation with R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="foreword-1st-edition.html">Foreword (1st Edition)</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Introduction</a></li>
<li class="book-part">Foundations</li>
<li><a class="" href="spatial-class.html"><span class="header-section-number">2</span> Geographic data in R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> Attribute data operations</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> Spatial data operations</a></li>
<li><a class="" href="geometric-operations.html"><span class="header-section-number">5</span> Geometry operations</a></li>
<li><a class="" href="reproj-geo-data.html"><span class="header-section-number">6</span> Reprojecting geographic data</a></li>
<li><a class="" href="read-write.html"><span class="header-section-number">7</span> Geographic data I/O</a></li>
<li class="book-part">Extensions</li>
<li><a class="" href="adv-map.html"><span class="header-section-number">8</span> Making maps with R</a></li>
<li><a class="" href="gis.html"><span class="header-section-number">9</span> Bridges to GIS software</a></li>
<li><a class="active" href="algorithms.html"><span class="header-section-number">10</span> Scripts, algorithms and functions</a></li>
<li><a class="" href="spatial-cv.html"><span class="header-section-number">11</span> Statistical learning</a></li>
<li class="book-part">Applications</li>
<li><a class="" href="transport.html"><span class="header-section-number">12</span> Transportation</a></li>
<li><a class="" href="location.html"><span class="header-section-number">13</span> Geomarketing</a></li>
<li><a class="" href="eco.html"><span class="header-section-number">14</span> Ecology</a></li>
<li><a class="" href="conclusion.html"><span class="header-section-number">15</span> Conclusion</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/Robinlovelace/geocompr">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="algorithms" class="section level1" number="10">
<h1>
<span class="header-section-number">10</span> Scripts, algorithms and functions<a class="anchor" aria-label="anchor" href="#algorithms"><i class="fas fa-link"></i></a>
</h1>
<div id="prerequisites-8" class="section level2 unnumbered">
<h2>Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites-8"><i class="fas fa-link"></i></a>
</h2>
<p>This chapter primarily uses base R; the <strong>sf</strong> package is used to check the result of an algorithm we will develop.
It assumes you have an understanding of the geographic classes introduced in Chapter <a href="spatial-class.html#spatial-class">2</a> and how they can be used to represent a wide range of input file formats (see Chapter <a href="read-write.html#read-write">7</a>).</p>
</div>
<div id="intro-algorithms" class="section level2" number="10.1">
<h2>
<span class="header-section-number">10.1</span> Introduction<a class="anchor" aria-label="anchor" href="#intro-algorithms"><i class="fas fa-link"></i></a>
</h2>
<p>Chapter <a href="intro.html#intro">1</a> established that geocomputation is not only about using existing tools, but developing new ones, “in the form of shareable R scripts and functions.”
This chapter teaches these building blocks of reproducible code.
It also introduces low-level geometric algorithms, of the type used in Chapter <a href="gis.html#gis">9</a>.
Reading it should help you to understand how such algorithms work and to write code that can be used many times, by many people, on multiple datasets.
The chapter cannot, by itself, make you a skilled programmer.
Programming is hard and requires plenty of practice <span class="citation">(<a href="references.html#ref-abelson_structure_1996" role="doc-biblioref">Abelson, Sussman, and Sussman 1996</a>)</span>:</p>
<blockquote>
<p>To appreciate programming as an intellectual activity in its own right you must turn to computer programming; you must read and write computer programs — many of them.</p>
</blockquote>
<p>There are strong reasons for moving in that direction, however.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
This chapter does not teach programming itself.
For more on programming, we recommend &lt;span class="citation"&gt;&lt;a href="references.html#ref-wickham_advanced_2019" role="doc-biblioref"&gt;Wickham&lt;/a&gt; (&lt;a href="references.html#ref-wickham_advanced_2019" role="doc-biblioref"&gt;2019&lt;/a&gt;)&lt;/span&gt;, &lt;span class="citation"&gt;&lt;a href="references.html#ref-gillespie_efficient_2016" role="doc-biblioref"&gt;Gillespie and Lovelace&lt;/a&gt; (&lt;a href="references.html#ref-gillespie_efficient_2016" role="doc-biblioref"&gt;2016&lt;/a&gt;)&lt;/span&gt;, and &lt;span class="citation"&gt;&lt;a href="references.html#ref-xiao_gis_2016" role="doc-biblioref"&gt;Xiao&lt;/a&gt; (&lt;a href="references.html#ref-xiao_gis_2016" role="doc-biblioref"&gt;2016&lt;/a&gt;)&lt;/span&gt;. &lt;/p&gt;'><sup>57</sup></a>
The advantages of reproducibility go beyond allowing others to replicate your work:
reproducible code is often better in every way than code written to be run only once, including in terms of computational efficiency, scalability and ease of adapting and maintaining it.</p>
<p>Scripts are the basis of reproducible R code, a topic covered in Section <a href="algorithms.html#scripts">10.2</a>.
Algorithms are recipes for modifying inputs using a series of steps, resulting in an output, as described in Section <a href="algorithms.html#geometric-algorithms">10.3</a>.
To ease sharing and reproducibility, algorithms can be placed into functions.
That is the topic of Section <a href="algorithms.html#functions">10.4</a>.
The example of finding the centroid of a polygon will be used to tie these concepts together.
Chapter <a href="geometric-operations.html#geometric-operations">5</a> already introduced a centroid function <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code>, but this example highlights how seemingly simple operations are the result of comparatively complex code, affirming the following observation <span class="citation">(<a href="references.html#ref-wise_gis_2001" role="doc-biblioref">Wise 2001</a>)</span>:</p>
<blockquote>
<p>One of the most intriguing things about spatial data problems is that things which appear to be trivially easy to a human being can be surprisingly difficult on a computer.</p>
</blockquote>
<p>The example also reflects a secondary aim of the chapter which, following <span class="citation"><a href="references.html#ref-xiao_gis_2016" role="doc-biblioref">Xiao</a> (<a href="references.html#ref-xiao_gis_2016" role="doc-biblioref">2016</a>)</span>, is “not to duplicate what is available out there, but to show how things out there work.”</p>
</div>
<div id="scripts" class="section level2" number="10.2">
<h2>
<span class="header-section-number">10.2</span> Scripts<a class="anchor" aria-label="anchor" href="#scripts"><i class="fas fa-link"></i></a>
</h2>
<p>If functions distributed in packages are the building blocks of R code, scripts are the glue that holds them together, in a logical order, to create reproducible workflows.
To programming novices scripts may sound intimidating but they are simply plain text files, typically saved with an extension representing the language they contain.
R scripts are generally saved with a <code>.R</code> extension and named to reflect what they do.
An example is <code>10-hello.R</code>, a script file stored in the <code>code</code> folder of the book’s repository, which contains the following two lines of code:</p>
<div class="sourceCode" id="cb350"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Aim: provide a minimal R script</span>
<span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="st">"Hello geocompr"</span><span class="op">)</span></code></pre></div>
<p>The lines of code may not be particularly exciting but they demonstrate the point: scripts do not need to be complicated.
Saved scripts can be called and executed in their entirety with <code><a href="https://rdrr.io/r/base/source.html">source()</a></code>, as demonstrated below which shows how the comment is ignored but the instruction is executed:</p>
<div class="sourceCode" id="cb351"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/source.html">source</a></span><span class="op">(</span><span class="st">"code/10-hello.R"</span><span class="op">)</span>
<span class="co">#&gt; [1] "Hello geocompr"</span></code></pre></div>
<p>There are no strict rules on what can and cannot go into script files and nothing to prevent you from saving broken, non-reproducible code.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Lines of code that do not contain valid R should be commented out, by adding a &lt;code&gt;#&lt;/code&gt; to the start of the line, to prevent errors.
See line 1 of the &lt;code&gt;10-hello.R&lt;/code&gt; script.&lt;/p&gt;"><sup>58</sup></a>
There are, however, some conventions worth following:</p>
<ul>
<li><p>Write the script in order: just like the script of a film, scripts should have a clear order such as ‘setup,’ ‘data processing’ and ‘save results’ (roughly equivalent to ‘beginning,’ ‘middle’ and ‘end’ in a film).</p></li>
<li><p>Add comments to the script so other people (and your future self) can understand it. At a minimum, a comment should state the purpose of the script (see Figure <a href="algorithms.html#fig:codecheck">10.1</a>) and (for long scripts) divide it into sections. This can be done in RStudio, for example, with the shortcut <code>Ctrl+Shift+R</code>, which creates ‘foldable’ code section headings.</p></li>
<li><p>Above all, scripts should be reproducible: self-contained scripts that will work on any computer are more useful than scripts that only run on your computer, on a good day. This involves attaching required packages at the beginning, reading-in data from persistent sources (such as a reliable website) and ensuring that previous steps have been taken.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Prior steps can be referred to with a comment or with an if statement such as &lt;code&gt;if(!exists("x")) source("x.R")&lt;/code&gt; (which would run the script file &lt;code&gt;x.R&lt;/code&gt; if the object &lt;code&gt;x&lt;/code&gt; is missing).&lt;/p&gt;'><sup>59</sup></a></p></li>
</ul>
<p>It is hard to enforce reproducibility in R scripts, but there are tools that can help.
By default, RStudio  ‘code-checks’ R scripts and underlines faulty code with a red wavy line, as illustrated below:</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:codecheck"></span>
<img src="figures/codecheck.png" alt="Code checking in RStudio. This example, from the script 10-centroid-alg.R, highlights an unclosed curly bracket on line 19." width="100%"><p class="caption">
FIGURE 10.1: Code checking in RStudio. This example, from the script 10-centroid-alg.R, highlights an unclosed curly bracket on line 19.
</p>
</div>

<div class="rmdnote">
A useful tool for reproducibility is the <strong>reprex</strong> package.
Its main function <code>reprex()</code> tests lines of R code to check if they are reproducible, and provides markdown output to facilitate communication on sites such as GitHub.
See the web page reprex.tidyverse.org for details.
</div>
<p></p>
<p>The contents of this section apply to any type of R script.
A particular consideration with scripts for geocomputation is that they tend to have external dependencies, such as the QGIS dependency to run code in Chapter <a href="gis.html#gis">9</a>, and require input data in a specific format.
Such dependencies should be mentioned as comments in the script or elsewhere in the project of which it is a part, as illustrated in the script <a href="https://github.com/Robinlovelace/geocompr/blob/main/code/10-centroid-alg.R"><code>10-centroid-alg.R</code></a>.
The work undertaken by this script is demonstrated in the reproducible example below, which works on a pre-requisite object named <code>poly_mat</code>, a square with sides 9 units in length (the meaning of this will become apparent in the next section):<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
This example shows that &lt;code&gt;source()&lt;/code&gt; works with URLs (a shortened version is used here), assuming you have an internet connection.
If you do not, the same script can be called with &lt;code&gt;source("code/10-centroid-alg.R")&lt;/code&gt;, assuming you are running R from the root directory of the &lt;code&gt;geocompr&lt;/code&gt; folder, which can be downloaded from &lt;a href="https://github.com/Robinlovelace/geocompr" class="uri"&gt;https://github.com/Robinlovelace/geocompr&lt;/a&gt;.&lt;/p&gt;'><sup>60</sup></a></p>
<div class="sourceCode" id="cb352"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">poly_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span>
  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">9</span>, <span class="fl">9</span>, <span class="fl">0</span><span class="op">)</span>,
  y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">9</span>, <span class="fl">9</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>
<span class="op">)</span>
<span class="kw"><a href="https://rdrr.io/r/base/source.html">source</a></span><span class="op">(</span><span class="st">"https://git.io/10-centroid-alg.R"</span><span class="op">)</span> <span class="co"># short url</span></code></pre></div>
<pre><code>#&gt; [1] "The area is: 81"
#&gt; [1] "The coordinates of the centroid are: 4.5, 4.5"</code></pre>
</div>
<div id="geometric-algorithms" class="section level2" number="10.3">
<h2>
<span class="header-section-number">10.3</span> Geometric algorithms<a class="anchor" aria-label="anchor" href="#geometric-algorithms"><i class="fas fa-link"></i></a>
</h2>
<p>Algorithms can be understood as the computing equivalent of a cooking recipe.
They are a complete set of instructions which, when undertaken on the input (ingredients), result in useful (tasty) outputs.
Before diving into a concrete case study, a brief history will show how algorithms relate to scripts (covered in Section <a href="algorithms.html#scripts">10.2</a>) and functions (which can be used to generalize algorithms, as we’ll see in Section <a href="algorithms.html#functions">10.4</a>).</p>
<p>The word “algorithm” originated in 9<sup>th</sup> century Baghdad with the publication of <em>Hisab al-jabr w’al-muqabala</em>, an early math textbook.
The book was translated into Latin and became so popular that the author’s last name, <a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi">al-Khwārizmī</a>, “was immortalized as a scientific term: Al-Khwarizmi
became Alchoarismi, Algorismi and, eventually, algorithm” <span class="citation">(<a href="references.html#ref-bellos_alex_2011" role="doc-biblioref">Bellos 2011</a>)</span>.
In the computing age, algorithm refers to a series of steps that solves a problem, resulting in a pre-defined output.
Inputs must be formally defined in a suitable data structure <span class="citation">(<a href="references.html#ref-wise_gis_2001" role="doc-biblioref">Wise 2001</a>)</span>.
Algorithms often start as flow charts or pseudocode showing the aim of the process before being implemented in code.
To ease usability, common algorithms are often packaged inside functions, which may hide some or all of the steps taken (unless you look at the function’s source code, see Section <a href="algorithms.html#functions">10.4</a>).</p>
<p>Geoalgorithms, such as those we encountered in Chapter <a href="gis.html#gis">9</a>, are algorithms that take geographic data in and, generally, return geographic results (alternative terms for the same thing include <em>GIS algorithms</em> and <em>geometric algorithms</em>).
That may sound simple but it is a deep subject with an entire academic field, <em>Computational Geometry</em>, dedicated to their study <span class="citation">(<a href="references.html#ref-berg_computational_2008" role="doc-biblioref">Berg et al. 2008</a>)</span> and numerous books on the subject.
<span class="citation"><a href="references.html#ref-orourke_computational_1998" role="doc-biblioref">O’Rourke</a> (<a href="references.html#ref-orourke_computational_1998" role="doc-biblioref">1998</a>)</span>, for example, introduces the subject with a range of progressively harder geometric algorithms using reproducible and freely available C code.</p>
<p>An example of a geometric algorithm is one that finds the centroid of a polygon.
There are many approaches to centroid calculation, some of which work only on specific types of <a href="https://en.wikipedia.org/wiki/Centroid">spatial data</a>.
For the purposes of this section, we choose an approach that is easy to visualize: breaking the polygon into many triangles and finding the centroid of each of these, an approach discussed by <span class="citation"><a href="references.html#ref-kaiser_algorithms_1993" role="doc-biblioref">Kaiser and Morin</a> (<a href="references.html#ref-kaiser_algorithms_1993" role="doc-biblioref">1993</a>)</span> alongside other centroid algorithms <span class="citation">(and mentioned briefly in <a href="references.html#ref-orourke_computational_1998" role="doc-biblioref">O’Rourke 1998</a>)</span>.
It helps to further break down this approach into discrete tasks before writing any code (subsequently referred to as step 1 to step 4, these could also be presented as a schematic diagram or pseudocode):</p>
<ol style="list-style-type: decimal">
<li>Divide the polygon into contiguous triangles.</li>
<li>Find the centroid of each triangle.</li>
<li>Find the area of each triangle.</li>
<li>Find the area-weighted mean of triangle centroids.</li>
</ol>
<p>These steps may sound straightforward, but converting words into working code requires some work and plenty of trial-and-error, even when the inputs are constrained:
The algorithm will only work for <em>convex polygons</em>, which contain no internal angles greater than 180°, no star shapes allowed (packages <strong>decido</strong> and <strong>sfdct</strong> can triangulate non-convex polygons using external libraries, as shown in the <a href="https://geocompr.github.io/geocompkg/articles/algorithm.html">algorithm</a> vignette at geocompr.github.io).</p>
<p>The simplest data structure of a polygon is a matrix of x and y coordinates in which each row represents a vertex tracing the polygon’s border in order where the first and last rows are identical <span class="citation">(<a href="references.html#ref-wise_gis_2001" role="doc-biblioref">Wise 2001</a>)</span>.
In this case, we’ll create a polygon with five vertices in base R, building on an example from <em>GIS Algorithms</em> <span class="citation">(<a href="references.html#ref-xiao_gis_2016" role="doc-biblioref">Xiao 2016</a> see <a href="https://github.com/gisalgs/geom" role="doc-biblioref">github.com/gisalgs</a> for Python code)</span>, as illustrated in Figure <a href="algorithms.html#fig:polymat">10.2</a>:</p>
<div class="sourceCode" id="cb354"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># generate a simple matrix representation of a polygon:</span>
<span class="va">x_coords</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">12</span>, <span class="fl">20</span>, <span class="fl">10</span><span class="op">)</span>
<span class="va">y_coords</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">10</span>, <span class="fl">20</span>, <span class="fl">15</span>, <span class="fl">0</span><span class="op">)</span>
<span class="va">poly_mat</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="va">x_coords</span>, <span class="va">y_coords</span><span class="op">)</span></code></pre></div>
<p>Now that we have an example dataset, we are ready to undertake step 1 outlined above.
The code below shows how this can be done by creating a single triangle (<code>T1</code>), that demonstrates the method; it also demonstrates step 2 by calculating its centroid based on the <a href="https://math.stackexchange.com/q/1702595/">formula</a> <span class="math inline">\(1/3(a + b + c)\)</span> where <span class="math inline">\(a\)</span> to <span class="math inline">\(c\)</span> are coordinates representing the triangle’s vertices:</p>
<div class="sourceCode" id="cb355"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># create a point representing the origin:</span>
<span class="va">Origin</span> <span class="op">=</span> <span class="va">poly_mat</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span>
<span class="co"># create 'triangle matrix':</span>
<span class="va">T1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">Origin</span>, <span class="va">poly_mat</span><span class="op">[</span><span class="fl">2</span><span class="op">:</span><span class="fl">3</span>, <span class="op">]</span>, <span class="va">Origin</span><span class="op">)</span> 
<span class="co"># find centroid (drop = FALSE preserves classes, resulting in a matrix):</span>
<span class="va">C1</span> <span class="op">=</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span> <span class="op">+</span> <span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span> <span class="op">+</span> <span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, , drop <span class="op">=</span> <span class="cn">FALSE</span><span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">3</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:polymat"></span>
<img src="10-algorithms_files/figure-html/polymat-1.png" alt="Illustration of polygon centroid calculation problem." width="100%"><p class="caption">
FIGURE 10.2: Illustration of polygon centroid calculation problem.
</p>
</div>
<p>Step 3 is to find the area of each triangle, so a <em>weighted mean</em> accounting for the disproportionate impact of large triangles is accounted for.
The formula to calculate the area of a triangle is as follows <span class="citation">(<a href="references.html#ref-kaiser_algorithms_1993" role="doc-biblioref">Kaiser and Morin 1993</a>)</span>:</p>
<p><span class="math display">\[
\frac{Ax ( B y − C y ) + B x ( C y − A y ) + C x ( A y − B y )}
{ 2 }
\]</span></p>
<p>Where <span class="math inline">\(A\)</span> to <span class="math inline">\(C\)</span> are the triangle’s three points and <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> refer to the x and y dimensions.
A translation of this formula into R code that works with the data in the matrix representation of a triangle <code>T1</code> is as follows (the function <code><a href="https://rdrr.io/r/base/MathFun.html">abs()</a></code> ensures a positive result):</p>
<div class="sourceCode" id="cb356"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># calculate the area of the triangle represented by matrix T1:</span>
<span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span>
  <span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span>
  <span class="va">T1</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">T1</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">T1</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">)</span> <span class="op">/</span> <span class="fl">2</span>
<span class="co">#&gt; [1] 50</span></code></pre></div>
<p>This code chunk outputs the correct result.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
The result can be verified with the following formula (which assumes a horizontal base):
area is half of the base width times height, &lt;span class="math inline"&gt;\(A = B * H / 2\)&lt;/span&gt;.
In this case &lt;span class="math inline"&gt;\(10 * 10 / 2 = 50\)&lt;/span&gt;.&lt;/p&gt;'><sup>61</sup></a>
The problem is that code is clunky and must by re-typed if we want to run it on another triangle matrix.
To make the code more generalizable, we will see how it can be converted into a function in Section <a href="algorithms.html#functions">10.4</a>.</p>
<p>Step 4 requires steps 2 and 3 to be undertaken not just on one triangle (as demonstrated above) but on all triangles.
This requires <em>iteration</em> to create all triangles representing the polygon, illustrated in Figure <a href="algorithms.html#fig:polycent">10.3</a>.
<code><a href="https://rdrr.io/r/base/lapply.html">lapply()</a></code> and <code><a href="https://rdrr.io/r/base/lapply.html">vapply()</a></code> are used to iterate over each triangle here because they provide a concise solution in base R:<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
See &lt;code&gt;?lapply&lt;/code&gt; for documentation and Chapter &lt;a href="location.html#location"&gt;13&lt;/a&gt; for more on iteration.&lt;/p&gt;'><sup>62</sup></a></p>
<div class="sourceCode" id="cb357"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">i</span> <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/ncell.html">nrow</a></span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span> <span class="op">-</span> <span class="fl">2</span><span class="op">)</span>
<span class="va">T_all</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">i</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">Origin</span>, <span class="va">poly_mat</span><span class="op">[</span><span class="va">x</span><span class="op">:</span><span class="op">(</span><span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>, <span class="op">]</span>, <span class="va">Origin</span><span class="op">)</span>
<span class="op">}</span><span class="op">)</span>

<span class="va">C_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">T_all</span>,  <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">3</span><span class="op">)</span>
<span class="va">C</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span><span class="op">(</span><span class="va">rbind</span>, <span class="va">C_list</span><span class="op">)</span>

<span class="va">A</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">vapply</a></span><span class="op">(</span><span class="va">T_all</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span>
        <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span>
        <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">)</span> <span class="op">/</span> <span class="fl">2</span>
  <span class="op">}</span>, FUN.VALUE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:polycent"></span>
<img src="10-algorithms_files/figure-html/polycent-1.png" alt="Illustration of iterative centroid algorithm with triangles. The X represents the area-weighted centroid in iterations 2 and 3." width="100%"><p class="caption">
FIGURE 10.3: Illustration of iterative centroid algorithm with triangles. The X represents the area-weighted centroid in iterations 2 and 3.
</p>
</div>
<p>We are now in a position to complete step 4 to calculate the total area with <code>sum(A)</code> and the centroid coordinates of the polygon with <code>weighted.mean(C[, 1], A)</code> and <code>weighted.mean(C[, 2], A)</code> (exercise for alert readers: verify these commands work).
To demonstrate the link between algorithms and scripts, the contents of this section have been condensed into <code>10-centroid-alg.R</code>.
We saw at the end of Section <a href="algorithms.html#scripts">10.2</a> how this script can calculate the centroid of a square.
The great thing about <em>scripting</em> the algorithm is that it works on the new <code>poly_mat</code> object (see exercises below to verify these results with reference to <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code>):</p>
<div class="sourceCode" id="cb358"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/source.html">source</a></span><span class="op">(</span><span class="st">"code/10-centroid-alg.R"</span><span class="op">)</span>
<span class="co">#&gt; [1] "The area is: 245"</span>
<span class="co">#&gt; [1] "The coordinates of the centroid are: 8.83, 9.22"</span></code></pre></div>
<p>The example above shows that low-level geographic operations <em>can</em> be developed from first principles with base R.
It also shows that if a tried-and-tested solution already exists, it may not be worth re-inventing the wheel:
if we aimed only to find the centroid of a polygon, it would have been quicker to represent <code>poly_mat</code> as an <strong>sf</strong> object and use the pre-existing <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code> function instead.
However, the great benefit of writing algorithms from 1<sup>st</sup> principles is that you will understand every step of the process, something that cannot be guaranteed when using other peoples’ code.
A further consideration is performance: R is slow compared with low-level languages such as C++ for number crunching (see Section <a href="intro.html#software-for-geocomputation">1.3</a>) and optimization is difficult.
If the aim is to develop new methods, computational efficiency should not be prioritized.
This is captured in the saying “premature optimization is the root of all evil (or at least most of it) in programming” <span class="citation">(<a href="references.html#ref-knuth_computer_1974" role="doc-biblioref">Knuth 1974</a>)</span>.</p>
<p>Algorithm development is hard.
This should be apparent from the amount of work that has gone into developing a centroid algorithm in base R that is just one, rather inefficient, approach to the problem with limited real-world applications (convex polygons are uncommon in practice).
The experience should lead to an appreciation of low-level geographic libraries such as GEOS (which underlies <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code>) and CGAL (the Computational Geometry Algorithms Library) which not only run fast but work on a wide range of input geometry types.
A great advantage of the open source nature of such libraries is that their source code is readily available for study, comprehension and (for those with the skills and confidence) modification.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
The CGAL function &lt;code&gt;CGAL::centroid()&lt;/code&gt; is in fact composed of 7 sub-functions as described at &lt;a href="https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html" class="uri"&gt;https://doc.cgal.org/latest/Kernel_23/group__centroid__grp.html&lt;/a&gt; allowing it to work on a wide range of input data types, whereas the solution we created works only on a very specific input data type.
The source code underlying GEOS function &lt;code&gt;Centroid::getCentroid()&lt;/code&gt; can be found at &lt;a href="https://github.com/libgeos/geos/search?q=getCentroid" class="uri"&gt;https://github.com/libgeos/geos/search?q=getCentroid&lt;/a&gt;.&lt;/p&gt;'><sup>63</sup></a></p>
</div>
<div id="functions" class="section level2" number="10.4">
<h2>
<span class="header-section-number">10.4</span> Functions<a class="anchor" aria-label="anchor" href="#functions"><i class="fas fa-link"></i></a>
</h2>
<p>Like algorithms, functions take an input and return an output.
Functions, however, refer to the implementation in a particular programming language, rather than the ‘recipe’ itself.
In R, functions are objects in their own right, that can be created and joined together in a modular fashion.
We can, for example, create a function that undertakes step 2 of our centroid generation algorithm as follows:</p>
<div class="sourceCode" id="cb359"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t_centroid</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span>
  <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">3</span>
<span class="op">}</span></code></pre></div>
<p>The above example demonstrates two key components of <a href="http://adv-r.had.co.nz/Functions.html">functions</a>:
1) the function <em>body</em>, the code inside the curly brackets that define what the function does with the inputs; and 2) the <em>formals</em>, the list of arguments the function works with — <code>x</code> in this case (the third key component, the environment, is beyond the scope of this section).
By default, functions return the last object that has been calculated (the coordinates of the centroid in the case of <code>t_centroid()</code>).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
You can also explicitly set the output of a function by adding &lt;code&gt;return(output)&lt;/code&gt; into the body of the function, where &lt;code&gt;output&lt;/code&gt; is the result to be returned.&lt;/p&gt;"><sup>64</sup></a></p>
<p>The function now works on any inputs you pass it, as illustrated in the below command which calculates the area of the 1<sup>st</sup> triangle from the example polygon in the previous section (see Figure <a href="algorithms.html#fig:polycent">10.3</a>):</p>
<div class="sourceCode" id="cb360"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">t_centroid</span><span class="op">(</span><span class="va">T1</span><span class="op">)</span>
<span class="co">#&gt; x_coords y_coords </span>
<span class="co">#&gt;     3.33     3.33</span></code></pre></div>
<p>We can also create a function to calculate a triangle’s area, which we will name <code>t_area()</code>:</p>
<div class="sourceCode" id="cb361"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t_area</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span>
    <span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span>
    <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span> <span class="op">+</span>
    <span class="va">x</span><span class="op">[</span><span class="fl">3</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">-</span> <span class="va">x</span><span class="op">[</span><span class="fl">2</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span>
  <span class="op">)</span> <span class="op">/</span> <span class="fl">2</span>
<span class="op">}</span></code></pre></div>
<p>Note that after the function’s creation, a triangle’s area can be calculated in a single line of code, avoiding duplication of verbose code:
functions are a mechanism for <em>generalizing</em> code.
The newly created function <code>t_area()</code> takes any object <code>x</code>, assumed to have the same dimensions as the ‘triangle matrix’ data structure we’ve been using, and returns its area, as illustrated on <code>T1</code> as follows:</p>
<div class="sourceCode" id="cb362"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">t_area</span><span class="op">(</span><span class="va">T1</span><span class="op">)</span>
<span class="co">#&gt; [1] 50</span></code></pre></div>
<p>We can test the generalizability of the function by using it to find the area of a new triangle matrix, which has a height of 1 and a base of 3:</p>
<div class="sourceCode" id="cb363"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">t_new</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">3</span>, <span class="fl">3</span>, <span class="fl">0</span><span class="op">)</span>,
              y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span><span class="op">)</span>
<span class="fu">t_area</span><span class="op">(</span><span class="va">t_new</span><span class="op">)</span>
<span class="co">#&gt;   x </span>
<span class="co">#&gt; 1.5</span></code></pre></div>
<p>A useful feature of functions is that they are modular.
Provided that you know what the output will be, one function can be used as the building block of another.
Thus, the functions <code>t_centroid()</code> and <code>t_area()</code> can be used as sub-components of a larger function to do the work of the script <code>10-centroid-alg.R</code>: calculate the area of any convex polygon.
The code chunk below creates the function <code>poly_centroid()</code> to mimic the behavior of <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code> for convex polygons:<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Note that the functions we created are called iteratively in &lt;code&gt;lapply()&lt;/code&gt; and &lt;code&gt;vapply()&lt;/code&gt; function calls.&lt;/p&gt;"><sup>65</sup></a></p>
<div class="sourceCode" id="cb364"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">poly_centroid</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">Origin</span> <span class="op">=</span> <span class="va">poly_mat</span><span class="op">[</span><span class="fl">1</span>, <span class="op">]</span> <span class="co"># create a point representing the origin</span>
  <span class="va">i</span> <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/ncell.html">nrow</a></span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span> <span class="op">-</span> <span class="fl">2</span><span class="op">)</span>
  <span class="va">T_all</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">i</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span>
    <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">rbind</a></span><span class="op">(</span><span class="va">Origin</span>, <span class="va">poly_mat</span><span class="op">[</span><span class="va">x</span><span class="op">:</span><span class="op">(</span><span class="va">x</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>, <span class="op">]</span>, <span class="va">Origin</span><span class="op">)</span>
  <span class="op">}</span><span class="op">)</span>
  <span class="va">C_list</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">T_all</span>, <span class="va">t_centroid</span><span class="op">)</span>
  <span class="va">C</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/do.call.html">do.call</a></span><span class="op">(</span><span class="va">rbind</span>, <span class="va">C_list</span><span class="op">)</span>
  <span class="va">A</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/lapply.html">vapply</a></span><span class="op">(</span><span class="va">T_all</span>, <span class="va">t_area</span>, FUN.VALUE <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/double.html">double</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>
  <span class="fu"><a href="https://rdrr.io/pkg/terra/man/c.html">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/raster/man/weighted.mean.html">weighted.mean</a></span><span class="op">(</span><span class="va">C</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, <span class="va">A</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/pkg/raster/man/weighted.mean.html">weighted.mean</a></span><span class="op">(</span><span class="va">C</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, <span class="va">A</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<div class="sourceCode" id="cb365"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">poly_centroid</span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span>
<span class="co">#&gt; [1] 8.83 9.22</span></code></pre></div>
<p>Functions such as <code>poly_centroid()</code> can further be extended to provide different types of output.
To return the result as an object of class <code>sfg</code>, for example, a ‘wrapper’ function can be used to modify the output of <code>poly_centroid()</code> before returning the result:</p>
<div class="sourceCode" id="cb366"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">poly_centroid_sfg</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">{</span>
  <span class="va">centroid_coords</span> <span class="op">=</span> <span class="fu">poly_centroid</span><span class="op">(</span><span class="va">x</span><span class="op">)</span>
  <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_point</a></span><span class="op">(</span><span class="va">centroid_coords</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>We can verify that the output is the same as the output from <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">sf::st_centroid()</a></code> as follows:</p>
<div class="sourceCode" id="cb367"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">poly_sfc</span> <span class="op">=</span> <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/identical.html">identical</a></span><span class="op">(</span><span class="fu">poly_centroid_sfg</span><span class="op">(</span><span class="va">poly_mat</span><span class="op">)</span>, <span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">poly_sfc</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
</div>
<div id="programming" class="section level2" number="10.5">
<h2>
<span class="header-section-number">10.5</span> Programming<a class="anchor" aria-label="anchor" href="#programming"><i class="fas fa-link"></i></a>
</h2>
<p>In this chapter we have moved quickly, from scripts to functions via the tricky topic of algorithms.
Not only have we discussed them in the abstract, but we have also created working examples of each to solve a specific problem:</p>
<ul>
<li>The script <code>10-centroid-alg.R</code> was introduced and demonstrated on a ‘polygon matrix’</li>
<li>The individual steps that allowed this script to work were described as an algorithm, a computational recipe</li>
<li>To generalize the algorithm we converted it into modular functions which were eventually combined to create the function <code>poly_centroid()</code> in the previous section</li>
</ul>
<p>Taken on its own, each of these steps is straightforward.
But the skill of programming is combining scripts, algorithms and functions in a way that produces performant, robust and user-friendly tools that other people can use.
If you are new to programming, as we expect most people reading this book will be, being able to follow and reproduce the results in the preceding sections should be seen as a major achievement.
Programming takes many hours of dedicated study and practice before you become proficient.</p>
<p>The challenge facing developers aiming to implement new algorithms in an efficient way is put in perspective by considering that we have only created a toy function.
In its current state, <code>poly_centroid()</code> fails on most (non-convex) polygons!
A question arising from this is: how would one generalize the function?
Two options are (1) to find ways to triangulate non-convex polygons (a topic covered in the online <a href="https://geocompr.github.io/geocompkg/articles/algorithm.html">algorithm</a> article that supports this chapter) and (2) to explore other centroid algorithms that do not rely on triangular meshes.</p>
<p>A wider question is: is it worth programming a solution at all when high performance algorithms have already been implemented and packaged in functions such as <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code>?
The reductionist answer in this specific case is ‘no.’
In the wider context, and considering the benefits of learning to program, the answer is ‘it depends.’
With programming, it’s easy to waste hours trying to implement a method, only to find that someone has already done the hard work.
So instead of seeing this chapter as your first stepping stone towards geometric algorithm programming wizardry, it may be more productive to use it as a lesson in when to try to program a generalized solution, and when to use existing higher-level solutions.
There will surely be occasions when writing new functions is the best way forward, but there will also be times when using functions that already exist is the best way forward.</p>
<p>We cannot guarantee that, having read this chapter, you will be able to rapidly create new functions for your work.
But we are confident that its contents will help you decide when is an appropriate time to try (when no other existing functions solve the problem, when the programming task is within your capabilities and when the benefits of the solution are likely to outweigh the time costs of developing it).
First steps towards programming can be slow (the exercises below should not be rushed) but the long-term rewards can be large.</p>
</div>
<div id="ex-algorithms" class="section level2" number="10.6">
<h2>
<span class="header-section-number">10.6</span> Exercises<a class="anchor" aria-label="anchor" href="#ex-algorithms"><i class="fas fa-link"></i></a>
</h2>
<ol style="list-style-type: decimal">
<li>Read the script <code>10-centroid-alg.R</code> in the <code>code</code> folder of the book’s GitHub repo.
<ul>
<li>Which of the best practices covered in Section <a href="algorithms.html#scripts">10.2</a> does it follow?</li>
<li>Create a version of the script on your computer in an IDE such as RStudio (preferably by typing-out the script line-by-line, in your own coding style and with your own comments, rather than copy-pasting — this will help you learn how to type scripts). Using the example of a square polygon (e.g., created with <code>poly_mat = cbind(x = c(0, 0, 9, 9, 0), y = c(0, 9, 9, 0, 0))</code>) execute the script line-by-line.</li>
<li>What changes could be made to the script to make it more reproducible?
<!-- - Answer: The script could state that it needs a an object called `poly_mat` to be present and, if none is present, create an example dataset at the outset for testing. -->
<!-- 1. Check-out the script `10-earthquakes.R` in the `code` folder of the book's GitHub [repo](https://github.com/Robinlovelace/geocompr/blob/main/code/10-earthquakes.R). -->
<!--     - Try to reproduce the results: how many significant earthquakes were there last month? -->
<!--     - Modify the script so that it provides a map with all earthquakes that happened in the past hour. -->
<!-- change line 10 to: -->
<!-- u = "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_hour.geojson" -->
</li>
<li>How could the documentation be improved?
<!-- It could document the source of the data better - e.g. with `data from https://earthquake.usgs.gov/earthquakes/feed/v1.0/geojson.php` -->
</li>
</ul>
</li>
<li>In Section <a href="algorithms.html#geometric-algorithms">10.3</a> we calculated that the area and geographic centroid of the polygon represented by <code>poly_mat</code> was 245 and 8.8, 9.2, respectively.
<ul>
<li>Reproduce the results on your own computer with reference to the script <code>10-centroid-alg.R</code>, an implementation of this algorithm (bonus: type out the commands - try to avoid copy-pasting).
<!-- Todo: add link to that script file (RL) -->
</li>
<li>Are the results correct? Verify them by converting <code>poly_mat</code> into an <code>sfc</code> object (named <code>poly_sfc</code>) with <code><a href="https://r-spatial.github.io/sf/reference/st.html">st_polygon()</a></code> (hint: this function takes objects of class <code><a href="https://rdrr.io/r/base/list.html">list()</a></code>) and then using <code><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_area()</a></code> and <code><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid()</a></code>.
<!-- We can verify the answer by converting `poly_mat` into a simple feature collection as follows, which shows the calculations match: -->
</li>
</ul>
</li>
<li>It was stated that the algorithm we created only works for <em>convex hulls</em>. Define convex hulls (see Chapter <a href="geometric-operations.html#geometric-operations">5</a>) and test the algorithm on a polygon that is <em>not</em> a convex hull.
<ul>
<li>Bonus 1: Think about why the method only works for convex hulls and note changes that would need to be made to the algorithm to make it work for other types of polygon.
<!-- The algorithm would need to be able to have negative as well as positive area values. -->
</li>
<li>Bonus 2: Building on the contents of <code>10-centroid-alg.R</code>, write an algorithm only using base R functions that can find the total length of linestrings represented in matrix form.
<!-- Todo: add example of matrix representing a linestring, demonstrate code to verify the answer, suggest alternative functions to decompose as a bonus. -->
</li>
</ul>
</li>
<li>In Section <a href="algorithms.html#functions">10.4</a> we created different versions of the <code>poly_centroid()</code> function that generated outputs of class <code>sfg</code> (<code>poly_centroid_sfg()</code>) and type-stable <code>matrix</code> outputs (<code>poly_centroid_type_stable()</code>). Further extend the function by creating a version (e.g., called <code>poly_centroid_sf()</code>) that is type stable (only accepts inputs of class <code>sf</code>) <em>and</em> returns <code>sf</code> objects (hint: you may need to convert the object <code>x</code> into a matrix with the command <code>sf::st_coordinates(x)</code>).
<ul>
<li>Verify it works by running <code>poly_centroid_sf(sf::st_sf(sf::st_sfc(poly_sfc)))</code>
</li>
<li>What error message do you get when you try to run <code>poly_centroid_sf(poly_mat)</code>?</li>
</ul>
</li>
</ol>
</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="gis.html"><span class="header-section-number">9</span> Bridges to GIS software</a></div>
<div class="next"><a href="spatial-cv.html"><span class="header-section-number">11</span> Statistical learning</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Note: Second Edition is under construction 🏗</h2>
    <p>Now is a great time to test in-development packages and provide feedback</p>
        <ul class="list-unstyled">
<li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Provide feedback (5 min)</a></li>
          <li><a href="https://geocompr.robinlovelace.net/#reproducibility">Install updated packages</a></li>
          <li><a href="https://github.com/Robinlovelace/geocompr/issues">Open an issue <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/Te3gWeDwmf">Chat on Discord <i class="fab fa-discord"></i></a></li>
        </ul>
<hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#algorithms"><span class="header-section-number">10</span> Scripts, algorithms and functions</a></li>
<li><a class="nav-link" href="#prerequisites-8">Prerequisites</a></li>
<li><a class="nav-link" href="#intro-algorithms"><span class="header-section-number">10.1</span> Introduction</a></li>
<li><a class="nav-link" href="#scripts"><span class="header-section-number">10.2</span> Scripts</a></li>
<li><a class="nav-link" href="#geometric-algorithms"><span class="header-section-number">10.3</span> Geometric algorithms</a></li>
<li><a class="nav-link" href="#functions"><span class="header-section-number">10.4</span> Functions</a></li>
<li><a class="nav-link" href="#programming"><span class="header-section-number">10.5</span> Programming</a></li>
<li><a class="nav-link" href="#ex-algorithms"><span class="header-section-number">10.6</span> Exercises</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/Robinlovelace/geocompr/blob/main/10-algorithms.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/Robinlovelace/geocompr/edit/main/10-algorithms.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation with R</strong>" was written by Robin Lovelace, Jakub Nowosad, Jannes Muenchow. It was last built on 2021-11-04.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
