<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Chapter 7 Reprojecting geographic data | Geocomputation with R</title>
<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">
<meta name="description" content="Prerequisites This chapter requires the following packages: library(sf) library(terra) library(dplyr) library(spData) library(spDataLarge)  7.1 Introduction Section 2.4 introduced coordinate...">
<meta name="generator" content="bookdown 0.43 with bs4_book()">
<meta property="og:title" content="Chapter 7 Reprojecting geographic data | Geocomputation with R">
<meta property="og:type" content="book">
<meta property="og:url" content="https://r.geocompx.org/reproj-geo-data.html">
<meta property="og:image" content="https://r.geocompx.org/images/cover2.png">
<meta property="og:description" content="Prerequisites This chapter requires the following packages: library(sf) library(terra) library(dplyr) library(spData) library(spDataLarge)  7.1 Introduction Section 2.4 introduced coordinate...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter 7 Reprojecting geographic data | Geocomputation with R">
<meta name="twitter:description" content="Prerequisites This chapter requires the following packages: library(sf) library(terra) library(dplyr) library(spData) library(spDataLarge)  7.1 Introduction Section 2.4 introduced coordinate...">
<meta name="twitter:image" content="https://r.geocompx.org/images/cover2.png">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><link href="libs/Lato-0.4.10/font.css" rel="stylesheet">
<link href="libs/Roboto_Mono-0.4.10/font.css" rel="stylesheet">
<link href="libs/Montserrat-0.4.10/font.css" rel="stylesheet">
<script src="libs/bs3compat-0.9.0/transition.js"></script><script src="libs/bs3compat-0.9.0/tabs.js"></script><script src="libs/bs3compat-0.9.0/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><meta name="citation_title" content="Chapter 7 Reprojecting geographic data | Geocomputation with R">
<meta name="citation_author" content="Robin Lovelace">
<meta name="citation_author" content="Jakub Nowosad">
<meta name="citation_author" content="Jannes Muenchow">
<meta name="citation_publication_date" content="2019">
<meta name="citation_isbn" content="9780203730058">
<link href="libs/htmltools-fill-0.5.8.1/fill.css" rel="stylesheet">
<script src="libs/htmlwidgets-1.6.4/htmlwidgets.js"></script><link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet">
<script src="libs/leaflet-1.3.1/leaflet.js"></script><link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet">
<script src="libs/proj4-2.6.2/proj4.min.js"></script><script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script><link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet">
<script src="libs/leaflet-binding-2.2.2/leaflet.js"></script><script src="libs/kePrint-0.0.1/kePrint.js"></script><link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet">
<link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
<script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-99618359-1', 'auto');
      ga('send', 'pageview');

    </script><!-- Google tag (gtag.js) --><script async src="https://www.googletagmanager.com/gtag/js?id=G-VDC2S0ZNH5"></script><script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-VDC2S0ZNH5');
    </script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS --><link rel="stylesheet" href="style/style.css">
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h2>
        <a href="index.html" title="">Geocomputation with R</a>
      </h2>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Welcome</a></li>
<li><a class="" href="foreword-1st-edition.html">Foreword (1st Edition)</a></li>
<li><a class="" href="foreword-2nd-edition.html">Foreword (2nd Edition)</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li><a class="" href="intro.html"><span class="header-section-number">1</span> Introduction</a></li>
<li class="book-part">Foundations</li>
<li><a class="" href="spatial-class.html"><span class="header-section-number">2</span> Geographic data in R</a></li>
<li><a class="" href="attr.html"><span class="header-section-number">3</span> Attribute data operations</a></li>
<li><a class="" href="spatial-operations.html"><span class="header-section-number">4</span> Spatial data operations</a></li>
<li><a class="" href="geometry-operations.html"><span class="header-section-number">5</span> Geometry operations</a></li>
<li><a class="" href="raster-vector.html"><span class="header-section-number">6</span> Raster-vector interactions</a></li>
<li><a class="active" href="reproj-geo-data.html"><span class="header-section-number">7</span> Reprojecting geographic data</a></li>
<li><a class="" href="read-write.html"><span class="header-section-number">8</span> Geographic data I/O</a></li>
<li class="book-part">Extensions</li>
<li><a class="" href="adv-map.html"><span class="header-section-number">9</span> Making maps with R</a></li>
<li><a class="" href="gis.html"><span class="header-section-number">10</span> Bridges to GIS software</a></li>
<li><a class="" href="algorithms.html"><span class="header-section-number">11</span> Scripts, algorithms and functions</a></li>
<li><a class="" href="spatial-cv.html"><span class="header-section-number">12</span> Statistical learning</a></li>
<li class="book-part">Applications</li>
<li><a class="" href="transport.html"><span class="header-section-number">13</span> Transportation</a></li>
<li><a class="" href="location.html"><span class="header-section-number">14</span> Geomarketing</a></li>
<li><a class="" href="eco.html"><span class="header-section-number">15</span> Ecology</a></li>
<li><a class="" href="conclusion.html"><span class="header-section-number">16</span> Conclusion</a></li>
<li><a class="" href="references.html">References</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/geocompx/geocompr">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="reproj-geo-data" class="section level1" number="7">
<h1>
<span class="header-section-number">7</span> Reprojecting geographic data<a class="anchor" aria-label="anchor" href="#reproj-geo-data"><i class="fas fa-link"></i></a>
</h1>
<div id="prerequisites-5" class="section level2 unnumbered">
<h2>Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites-5"><i class="fas fa-link"></i></a>
</h2>
<ul>
<li>This chapter requires the following packages:</li>
</ul>
<div class="sourceCode" id="cb223"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://r-spatial.github.io/sf/">sf</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://rspatial.org/">terra</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org">dplyr</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://jakubnowosad.com/spData/">spData</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/Nowosad/spData">spDataLarge</a></span><span class="op">)</span></span></code></pre></div>
</div>
<div id="reproj-intro" class="section level2" number="7.1">
<h2>
<span class="header-section-number">7.1</span> Introduction<a class="anchor" aria-label="anchor" href="#reproj-intro"><i class="fas fa-link"></i></a>
</h2>
<p>Section <a href="spatial-class.html#crs-intro">2.4</a> introduced coordinate reference systems (CRSs), with a focus on the two major types: <em>geographic</em> (‘lon/lat’, with units in degrees longitude and latitude) and <em>projected</em> (typically with units of meters from a datum) coordinate systems.
This chapter builds on that knowledge and goes further.
It demonstrates how to set and <em>transform</em> geographic data from one CRS to another and, furthermore, highlights specific issues that can arise due to ignoring CRSs that you should be aware of, especially if your data is stored with lon/lat coordinates.
</p>
<p>In many projects there is no need to worry about, let alone convert between, different CRSs.
Nonetheless, it is important to know if your data is in a projected or geographic CRS, and the consequences of this for geometry operations.
If you know this information, CRSs should <em>just work</em> behind the scenes: people often suddenly need to learn about CRSs when things go wrong.
Having a clearly defined CRS that all project data is in, and understanding how and why to use different CRSs, can ensure that things don’t go wrong.
Furthermore, learning about coordinate systems will deepen your knowledge of geographic datasets and how to use them effectively.</p>
<p>This chapter teaches the fundamentals of CRSs, demonstrates the consequences of using different CRSs (including what can go wrong), and how to ‘reproject’ datasets from one coordinate system to another.
In the next section, we introduce CRSs in R, followed by Section <a href="reproj-geo-data.html#crs-setting">7.3</a> which shows how to get and set CRSs associated with spatial objects.
Section <a href="reproj-geo-data.html#geom-proj">7.4</a> demonstrates the importance of knowing what CRS your data is in with reference to a worked example of creating buffers.
We tackle questions of when to reproject and which CRS to use in Section <a href="reproj-geo-data.html#whenproject">7.5</a> and Section <a href="reproj-geo-data.html#which-crs">7.6</a>, respectively.
Finally, we cover reprojecting vector and raster objects in Sections <a href="reproj-geo-data.html#reproj-vec-geom">7.7</a> and <a href="reproj-geo-data.html#reproj-ras">7.8</a> and modifying map projections in Section <a href="reproj-geo-data.html#mapproj">7.9</a>.</p>
</div>
<div id="crs-in-r" class="section level2" number="7.2">
<h2>
<span class="header-section-number">7.2</span> Coordinate reference systems<a class="anchor" aria-label="anchor" href="#crs-in-r"><i class="fas fa-link"></i></a>
</h2>
<p>
Most modern geographic tools that require CRS conversions, including core R-spatial packages and desktop GIS software such as QGIS, interface with <a href="https://proj.org">PROJ</a>, an open source C++ library that “transforms coordinates from one coordinate reference system (CRS) to another”.
CRSs can be described in many ways, including the following:</p>
<ol style="list-style-type: decimal">
<li>Simple yet potentially ambiguous statements such as “it’s in lon/lat coordinates”</li>
<li>Formalized yet now outdated ‘proj4 strings’ (also known as ‘proj-string’) such as <code>+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs</code>
</li>
<li>With an identifying ‘authority:code’ text string such as <code>EPSG:4326</code>
</li>
</ol>
<p>Each refers to the same thing: the ‘WGS84’ coordinate system that forms the basis of Global Positioning System (GPS) coordinates and many other datasets.
But which one is correct?</p>
<p>
The short answer is that the third way to identify CRSs is preferable: <code>EPSG:4326</code> is understood by <strong>sf</strong> (and by extension <strong>stars</strong>) and <strong>terra</strong> packages covered in this book, plus many other software projects for working with geographic data including <a href="https://docs.qgis.org/3.16/en/docs/user_manual/working_with_projections/working_with_projections.html">QGIS</a> and <a href="https://proj.org/development/quickstart.html">PROJ</a>.
<code>EPSG:4326</code> is future-proof.
Furthermore, although it is machine readable, “EPSG:4326” is short, easy to remember and highly ‘findable’ online (searching for EPSG:4326 yields a dedicated page on the website <a href="https://epsg.io/4326">epsg.io</a>, for example).
The more concise identifier <code>4326</code> is understood by <strong>sf</strong>, but <strong>we recommend the more explicit <code>AUTHORITY:CODE</code> representation to prevent ambiguity and to provide context</strong>.</p>
<p>
The longer answer is that none of the three descriptions are sufficient, and more detail is needed for unambiguous CRS handling and transformations: due to the complexity of CRSs, it is not possible to capture all relevant information about them in such short text strings.
For this reason, the Open Geospatial Consortium (OGC, which also developed the simple features specification that the <strong>sf</strong> package implements) developed an open standard format for describing CRSs that is called WKT (Well-Known Text).
This is detailed in a <a href="https://portal.opengeospatial.org/files/18-010r7">100+ page document</a> that “defines the structure and content of a text string implementation of the abstract model for coordinate reference systems described in ISO 19111:2019” <span class="citation">(<a href="references.html#ref-opengeospatialconsortium_wellknown_2019">Open Geospatial Consortium 2019</a>)</span>.
The WKT representation of the WGS84 CRS, which has the <strong>identifier</strong> <code>EPSG:4326</code> is as follows:</p>
<div class="sourceCode" id="cb224"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="st">"EPSG:4326"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: EPSG:4326 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt; GEOGCRS["WGS 84",</span></span>
<span><span class="co">#&gt;     ENSEMBLE["World Geodetic System 1984 ensemble",</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (Transit)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G730)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G873)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G1150)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G1674)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G1762)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G2139)"],</span></span>
<span><span class="co">#&gt;         ELLIPSOID["WGS 84",6378137,298.257223563,</span></span>
<span><span class="co">#&gt;             LENGTHUNIT["metre",1]],</span></span>
<span><span class="co">#&gt;         ENSEMBLEACCURACY[2.0]],</span></span>
<span><span class="co">#&gt;     PRIMEM["Greenwich",0,</span></span>
<span><span class="co">#&gt;         ANGLEUNIT["degree",0.0174532925199433]],</span></span>
<span><span class="co">#&gt;     CS[ellipsoidal,2],</span></span>
<span><span class="co">#&gt;         AXIS["geodetic latitude (Lat)",north,</span></span>
<span><span class="co">#&gt;             ORDER[1],</span></span>
<span><span class="co">#&gt;             ANGLEUNIT["degree",0.0174532925199433]],</span></span>
<span><span class="co">#&gt;         AXIS["geodetic longitude (Lon)",east,</span></span>
<span><span class="co">#&gt;             ORDER[2],</span></span>
<span><span class="co">#&gt;             ANGLEUNIT["degree",0.0174532925199433]],</span></span>
<span><span class="co">#&gt;     USAGE[</span></span>
<span><span class="co">#&gt;         SCOPE["Horizontal component of 3D system."],</span></span>
<span><span class="co">#&gt;         AREA["World."],</span></span>
<span><span class="co">#&gt;         BBOX[-90,-180,90,180]],</span></span>
<span><span class="co">#&gt;     ID["EPSG",4326]]</span></span></code></pre></div>
<p>
The output of the command shows how the CRS identifier (also known as a Spatial Reference Identifier or <a href="https://postgis.net/workshops/postgis-intro/projection.html">SRID</a>) works: it is simply a look-up, providing a unique identifier associated with a more complete WKT representation of the CRS.
This raises the question: what happens if there is a mismatch between the identifier and the longer WKT representation of a CRS?
On this point <span class="citation">Open Geospatial Consortium (<a href="references.html#ref-opengeospatialconsortium_wellknown_2019">2019</a>)</span> is clear, the verbose WKT representation takes precedence over the <a href="https://docs.ogc.org/is/18-010r7/18-010r7.html#37">identifier</a>:</p>
<blockquote>
<p>Should any attributes or values given in the cited identifier be in conflict with attributes or values given explicitly in the WKT description, the WKT values shall prevail.</p>
</blockquote>
<p>
The convention of referring to CRSs identifiers in the form <code>AUTHORITY:CODE</code>, which is also used by geographic software written in other <a href="https://jorisvandenbossche.github.io/blog/2020/02/11/geopandas-pyproj-crs/">languages</a>, allows a wide range of formally defined coordinate systems to be referred to.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Several other ways of referring to unique CRSs can be used, with five identifier types (EPSG code, PostGIS SRID, INTERNAL SRID, proj-string, and WKT strings) accepted by &lt;a href="https://docs.qgis.org/3.16/en/docs/pyqgis_developer_cookbook/crs.html?highlight=srid"&gt;QGIS&lt;/a&gt; and other identifier types such as a more verbose variant of the &lt;code&gt;EPSG:4326&lt;/code&gt; identifier, &lt;code&gt;urn:ogc:def:crs:EPSG::4326&lt;/code&gt; &lt;span class="citation"&gt;(&lt;a href="references.html#ref-opengeospatialconsortium_wellknown_2019"&gt;Open Geospatial Consortium 2019&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;'><sup>28</sup></a>
The most commonly used authority in CRS identifiers is <em>EPSG</em>, an acronym for the European Petroleum Survey Group which published a standardized list of CRSs (the EPSG was <a href="http://wiki.gis.com/wiki/index.php/European_Petroleum_Survey_Group">taken over</a> by the <a href="https://epsg.org/home.html">Geomatics Committee of the International Association of Oil &amp; Gas Producers</a> in 2005).
Other authorities can be used in CRS identifiers.
<code>ESRI:54030</code>, for example, refers to ESRI’s implementation of the Robinson projection, which has the following WKT string (only first eight lines shown):</p>
<div class="sourceCode" id="cb225"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="st">"ESRI:54030"</span><span class="op">)</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: ESRI:54030 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt; PROJCRS["World_Robinson",</span></span>
<span><span class="co">#&gt;     BASEGEOGCRS["WGS 84",</span></span>
<span><span class="co">#&gt;         DATUM["World Geodetic System 1984",</span></span>
<span><span class="co">#&gt;             ELLIPSOID["WGS 84",6378137,298.257223563,</span></span>
<span><span class="co">#&gt;                 LENGTHUNIT["metre",1]]],</span></span>
<span><span class="va">....</span></span></code></pre></div>
<p>
WKT strings are exhaustive, detailed, and precise, allowing for unambiguous CRSs storage and transformations.
They contain all relevant information about any given CRS, including its datum and ellipsoid, prime meridian, projection, and units.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Before the emergence of WKT CRS definitions, proj-string was the standard way to specify coordinate operations and store CRSs.
These string representations, built on a key=value form (e.g, &lt;code&gt;+proj=longlat +datum=WGS84 +no_defs&lt;/code&gt;), have already been, or should in the future be, superseded by WKT representations in most cases.&lt;/p&gt;"><sup>29</sup></a></p>
<p>
Recent PROJ versions (6+) still allow use of proj-strings to define coordinate operations, but some proj-string keys (<code>+nadgrids</code>, <code>+towgs84</code>, <code>+k</code>, <code>+init=epsg:</code>) are either no longer supported or are discouraged.
Additionally, only three datums (i.e., WGS84, NAD83, and NAD27) can be directly set in proj-string.
Longer explanations of the evolution of CRS definitions and the PROJ library can be found in <span class="citation">Bivand (<a href="references.html#ref-bivand_progress_2021">2021</a>)</span>, chapter 2 of <span class="citation">Pebesma and Bivand (<a href="references.html#ref-pebesma_spatial_2023">2023b</a>)</span>, and a <a href="https://inbo.github.io/tutorials/tutorials/spatial_crs_coding/">blog post by Floris Vanderhaeghe, available at inbo.github.io/tutorials/tutorials/spatial_crs_coding/</a>.
Also, as outlined in the <a href="https://proj.org/development/reference/cpp/cpp_general.html">PROJ documentation</a> there are different versions of the WKT CRS format including WKT1 and two variants of WKT2, the latter of which (WKT2, 2018 specification) corresponds to the ISO 19111:2019 <span class="citation">(<a href="references.html#ref-opengeospatialconsortium_wellknown_2019">Open Geospatial Consortium 2019</a>)</span>.</p>
</div>
<div id="crs-setting" class="section level2" number="7.3">
<h2>
<span class="header-section-number">7.3</span> Querying and setting coordinate systems<a class="anchor" aria-label="anchor" href="#crs-setting"><i class="fas fa-link"></i></a>
</h2>
<p>
Let’s look at how CRSs are stored in R spatial objects and how they can be queried and set.
First, we will look at getting and setting CRSs in <strong>vector</strong> geographic data objects, starting with the following example:</p>
<div class="sourceCode" id="cb226"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">vector_filepath</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"shapes/world.gpkg"</span>, package <span class="op">=</span> <span class="st">"spData"</span><span class="op">)</span></span>
<span><span class="va">new_vector</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf</a></span><span class="op">(</span><span class="va">vector_filepath</span><span class="op">)</span></span></code></pre></div>
<p>Our new object, <code>new_vector</code>, is a data frame of class <code>sf</code> that represents countries worldwide (see the help page <code><a href="https://jakubnowosad.com/spData/reference/world.html">?spData::world</a></code> for details).
The CRS can be retrieved with the <strong>sf</strong> function <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code>.</p>
<div class="sourceCode" id="cb227"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">new_vector</span><span class="op">)</span> <span class="co"># get CRS</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: WGS 84 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt;   ...</span></span></code></pre></div>
<p>
The output is a list containing two main components:</p>
<ol style="list-style-type: decimal">
<li>
<code>User input</code> (in this case <code>WGS 84</code>, a synonym for <code>EPSG:4326</code> which in this case was taken from the input file), corresponding to CRS identifiers described above</li>
<li>
<code>wkt</code>, containing the full WKT string with all relevant information about the CRS</li>
</ol>
<p>The <code>input</code> element is flexible, and depending on the input file or user input, can contain the <code>AUTHORITY:CODE</code> representation (e.g., <code>EPSG:4326</code>), the CRS’s name (e.g., <code>WGS 84</code>), or even the proj-string definition.
The <code>wkt</code> element stores the WKT representation, which is used when saving the object to a file or doing any coordinate operations.
Above, we can see that the <code>new_vector</code> object has the WGS84 ellipsoid, uses the Greenwich prime meridian, and the latitude and longitude axis order.
In this case, we also have some additional elements, such as <code>USAGE</code> explaining the area suitable for the use of this CRS, and <code>ID</code> pointing to the CRS’s identifier: <code>EPSG:4326</code>.</p>
<p>
The <code>st_crs</code> function also has one helpful feature – we can retrieve some additional information about the used CRS.
For example, try to run:</p>
<ul>
<li>
<code>st_crs(new_vector)$IsGeographic</code> to check if the CRS is geographic or not</li>
<li>
<code>st_crs(new_vector)$units_gdal</code> to find out the CRS units</li>
<li>
<code>st_crs(new_vector)$srid</code> to extract its ‘SRID’ identifier (when available)</li>
<li>
<code>st_crs(new_vector)$proj4string</code> to extract the proj-string representation</li>
</ul>
<p>In cases when a CRS is missing or the wrong CRS is set, the <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_set_crs()</a></code> function can be used (in this case the WKT string remains unchanged because the CRS was already set correctly when the file was read-in):</p>
<div class="sourceCode" id="cb228"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">new_vector</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_set_crs</a></span><span class="op">(</span><span class="va">new_vector</span>, <span class="st">"EPSG:4326"</span><span class="op">)</span> <span class="co"># set CRS</span></span></code></pre></div>
<p>
Getting and setting CRSs works in a similar way for raster geographic data objects.
The <code><a href="https://rspatial.github.io/terra/reference/crs.html">crs()</a></code> function in the <code>terra</code> package accesses CRS information from a <code>SpatRaster</code> object (note the use of the <code><a href="https://rdrr.io/r/base/cat.html">cat()</a></code> function to print it nicely).</p>
<div class="sourceCode" id="cb229"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">raster_filepath</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/srtm.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span></span>
<span><span class="va">my_rast</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="va">raster_filepath</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">my_rast</span><span class="op">)</span><span class="op">)</span> <span class="co"># get CRS</span></span>
<span><span class="co">#&gt; GEOGCRS["WGS 84",</span></span>
<span><span class="co">#&gt;     ENSEMBLE["World Geodetic System 1984 ensemble",</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (Transit)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G730)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G873)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G1150)"],</span></span>
<span><span class="va">....</span></span></code></pre></div>
<p>The output is the WKT string representation of CRS.
The same function, <code><a href="https://rspatial.github.io/terra/reference/crs.html">crs()</a></code>, can be also used to set a CRS for raster objects.</p>
<div class="sourceCode" id="cb230"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">my_rast</span><span class="op">)</span> <span class="op">=</span> <span class="st">"EPSG:26912"</span> <span class="co"># set CRS</span></span></code></pre></div>
<p>Here, we can use either the identifier (recommended in most cases) or complete WKT string representation.
Alternative methods to set <code>crs</code> include proj-string strings or CRSs extracted from other existing objects with <code><a href="https://rspatial.github.io/terra/reference/crs.html">crs()</a></code>, although these approaches may be less future-proof.</p>
<p>Importantly, the <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code> and <code><a href="https://rspatial.github.io/terra/reference/crs.html">crs()</a></code> functions do not alter coordinates’ values or geometries.
Their role is only to set a metadata information about the object CRS.</p>
<p>In some cases the CRS of a geographic object is unknown, as is the case in the <code>london</code> dataset created in the code chunk below, building on the example of London introduced in Section <a href="spatial-class.html#vector-data">2.2</a>:</p>
<div class="sourceCode" id="cb231"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">london</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>lon <span class="op">=</span> <span class="op">-</span><span class="fl">0.1</span>, lat <span class="op">=</span> <span class="fl">51.5</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span>coords <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"lon"</span>, <span class="st">"lat"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_is_longlat.html">st_is_longlat</a></span><span class="op">(</span><span class="va">london</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] NA</span></span></code></pre></div>
<p>The output <code>NA</code> shows that <strong>sf</strong> does not know what the CRS is and is unwilling to guess (<code>NA</code> literally means ‘not available’).
Unless a CRS is manually specified or is loaded from a source that has CRS metadata, <strong>sf</strong> does not make any explicit assumptions about which coordinate systems, other than to say “I don’t know”.
This behavior makes sense given the diversity of available CRSs but differs from some approaches, such as the GeoJSON file format specification, which makes the simplifying assumption that all coordinates have a lon/lat CRS: <code>EPSG:4326</code>.
Datasets without a specified CRS can cause problems: all geographic coordinates have a coordinate reference system, and software can only make good decisions around plotting and geometry operations if it knows what type of CRS it is working with.
Thus, again, it is important to always check the CRS of a dataset and to set it if it is missing.</p>
<div class="sourceCode" id="cb232"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">london_geo</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_set_crs</a></span><span class="op">(</span><span class="va">london</span>, <span class="st">"EPSG:4326"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_is_longlat.html">st_is_longlat</a></span><span class="op">(</span><span class="va">london_geo</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
</div>
<div id="geom-proj" class="section level2" number="7.4">
<h2>
<span class="header-section-number">7.4</span> Geometry operations on projected and unprojected data<a class="anchor" aria-label="anchor" href="#geom-proj"><i class="fas fa-link"></i></a>
</h2>
<p>Since <strong>sf</strong> version 1.0.0, R’s ability to work with geographic vector datasets that have lon/lat CRSs has improved substantially, thanks to its integration with the S2 <em>spherical geometry engine</em> introduced in Section <a href="spatial-class.html#s2">2.2.9</a>.
As shown in Figure <a href="reproj-geo-data.html#fig:s2geos">7.1</a>, <strong>sf</strong> uses either GEOS or the S2 depending on the type of CRS and whether S2 has been disabled (it is enabled by default).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;The &lt;code&gt;st_area()&lt;/code&gt; function is an exception, as it uses the &lt;strong&gt;lwgeom&lt;/strong&gt;’s &lt;code&gt;st_geod_area()&lt;/code&gt; function to calculate areas for data with geographic CRSs when &lt;code&gt;sf_use_s2()&lt;/code&gt; is disabled.&lt;/p&gt;"><sup>30</sup></a>
GEOS is always used for projected data and data with no CRS; for geographic data, S2 is used by default but can be disabled with <code>sf::sf_use_s2(FALSE)</code>.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:s2geos"></span>
<img src="images/07-s2geos.png" alt="Behavior of the geometry operations in the sf package depending on the input data's CRS." width="100%"><p class="caption">
FIGURE 7.1: Behavior of the geometry operations in the sf package depending on the input data’s CRS.
</p>
</div>
<p>To demonstrate the importance of CRSs, we will create a buffer of 100 km around the <code>london</code> object from the previous section.
We will also create a deliberately faulty buffer with a ‘distance’ of 1 degree, which is roughly equivalent to 100 km (1 degree is about 111 km at the equator).
Before diving into the code, it may be worth skipping briefly ahead to peek at Figure <a href="reproj-geo-data.html#fig:crs-buf">7.2</a> to get a visual handle on the outputs that you should be able to reproduce by following the code chunks below.</p>
<p>The first stage is to create three buffers around the <code>london</code> and <code>london_geo</code> objects created above with boundary distances of 1 degree and 100 km (or 100,000 m, which can be expressed as <code>1e5</code> in scientific notation) from central London:</p>
<div class="sourceCode" id="cb233"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">london_buff_no_crs</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">london</span>, dist <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>   <span class="co"># incorrect: no CRS</span></span>
<span><span class="va">london_buff_s2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">london_geo</span>, dist <span class="op">=</span> <span class="fl">100000</span><span class="op">)</span> <span class="co"># silent use of s2</span></span>
<span><span class="va">london_buff_s2_100_cells</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">london_geo</span>, dist <span class="op">=</span> <span class="fl">100000</span>, max_cells <span class="op">=</span> <span class="fl">100</span><span class="op">)</span> </span></code></pre></div>
<p>In the first line above, <strong>sf</strong> assumes that the input is projected and generates a result that has a buffer in units of degrees, which is problematic, as we will see.
In the second line, <strong>sf</strong> silently uses the spherical geometry engine S2, introduced in Chapter <a href="spatial-class.html#spatial-class">2</a>, to calculate the extent of the buffer using the default value of <code>max_cells = 1000</code> — set to <code>100</code> in line three — the consequences which will become apparent shortly.
To highlight the impact of <strong>sf</strong>’s use of the S2 geometry engine for unprojected (geographic) coordinate systems, we will temporarily disable it with the command <code><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2()</a></code> (which is on, <code>TRUE</code>, by default), in the code chunk below.
Like <code>london_buff_no_crs</code>, the new <code>london_geo</code> object is a geographic abomination: it has units of degrees, which makes no sense in the vast majority of cases:</p>
<div class="sourceCode" id="cb234"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Spherical geometry (s2) switched off</span></span>
<span><span class="va">london_buff_lonlat</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">london_geo</span>, dist <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># incorrect result</span></span>
<span><span class="co">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle =</span></span>
<span><span class="co">#&gt; endCapStyle, : st_buffer does not correctly buffer longitude/latitude data</span></span>
<span><span class="co">#&gt; dist is assumed to be in decimal degrees (arc_degrees).</span></span>
<span><span class="fu">sf</span><span class="fu">::</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2</a></span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt; Spherical geometry (s2) switched on</span></span></code></pre></div>
<p>The warning message above hints at issues with performing planar geometry operations on lon/lat data.
When spherical geometry operations are turned off, with the command <code>sf::sf_use_s2(FALSE)</code>, buffers (and other geometric operations) may result in worthless outputs because they use units of latitude and longitude, a poor substitute for proper units of distances such as meters.</p>

<div class="rmdnote">
The distance between two lines of longitude, called meridians, is around 111 km at the equator (execute <code>geosphere::distGeo(c(0, 0), c(1, 0))</code> to find the precise distance).
This shrinks to zero at the poles.
At the latitude of London, for example, meridians are less than 70 km apart (challenge: execute code that verifies this).
<!-- `geosphere::distGeo(c(0, 51.5), c(1, 51.5))` -->
Lines of latitude, by contrast, are equidistant from each other irrespective of latitude: they are always around 111 km apart, including at the equator and near the poles (see Figures <a href="reproj-geo-data.html#fig:crs-buf">7.2</a> to <a href="reproj-geo-data.html#fig:wintriproj">7.4</a>).
</div>
<p>Do not interpret the warning about the geographic (<code>longitude/latitude</code>) CRS as “the CRS should not be set”: it almost always should be!
It is better understood as a suggestion to <em>reproject</em> the data onto a projected CRS.
This suggestion does not always need to be heeded: performing spatial and geometric operations makes little or no difference in some cases (e.g., spatial subsetting).
But for operations involving distances such as buffering, the only way to ensure a good result (without using spherical geometry engines) is to create a projected copy of the data and run the operation on that.
This is done in the code chunk below.</p>
<div class="sourceCode" id="cb235"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">london_proj</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">530000</span>, y <span class="op">=</span> <span class="fl">180000</span><span class="op">)</span> <span class="op">|&gt;</span> </span>
<span>  <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_sf.html">st_as_sf</a></span><span class="op">(</span>coords <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"x"</span>, <span class="st">"y"</span><span class="op">)</span>, crs <span class="op">=</span> <span class="st">"EPSG:27700"</span><span class="op">)</span></span></code></pre></div>
<p>The result is a new object that is identical to <code>london</code>, but created using a suitable CRS (the British National Grid, which has an EPSG code of 27700 in this case) that has units of meters.
We can verify that the CRS has changed using <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code> as follows (some of the output has been replaced by <code>...,</code>):</p>
<div class="sourceCode" id="cb236"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">london_proj</span><span class="op">)</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: EPSG:27700 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt; PROJCRS["OSGB36 / British National Grid",</span></span>
<span><span class="co">#&gt;     BASEGEOGCRS["OSGB36",</span></span>
<span><span class="co">#&gt;         DATUM["Ordnance Survey of Great Britain 1936",</span></span>
<span><span class="co">#&gt;             ELLIPSOID["Airy 1830",6377563.396,299.3249646,</span></span>
<span><span class="co">#&gt;                 LENGTHUNIT["metre",1]]],</span></span>
<span><span class="va">....</span></span></code></pre></div>
<p>Notable components of this CRS description include the EPSG code (<code>EPSG: 27700</code>) and the detailed <code>wkt</code> string (only the first five lines of which are shown).<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
For a short description of the most relevant projection parameters and related concepts, see the fourth lecture by Jochen Albrecht hosted at
&lt;a href="http://www.geography.hunter.cuny.edu/~jochen/GTECH361/lectures/" class="uri"&gt;http://www.geography.hunter.cuny.edu/~jochen/GTECH361/lectures/&lt;/a&gt; and information at &lt;a href="https://proj.org/usage/projections.html" class="uri"&gt;https://proj.org/usage/projections.html&lt;/a&gt;.&lt;/p&gt;'><sup>31</sup></a>
The fact that the units of the CRS, described in the LENGTHUNIT field, are meters (rather than degrees) tells us that this is a projected CRS: <code>st_is_longlat(london_proj)</code> now returns <code>FALSE</code> and geometry operations on <code>london_proj</code> will work without a warning.
Buffer operations on the <code>london_proj</code> will use GEOS, and results will be returned with proper units of distance.
The following line of code creates a buffer around <em>projected</em> data of exactly 100 km:</p>
<div class="sourceCode" id="cb237"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">london_buff_projected</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_buffer</a></span><span class="op">(</span><span class="va">london_proj</span>, <span class="fl">100000</span><span class="op">)</span></span></code></pre></div>
<p>The geometries of the three <code>london_buff*</code> objects created in the preceding code that <em>have</em> a specified CRS (<code>london_buff_s2</code>, <code>london_buff_lonlat</code> and <code>london_buff_projected</code>) are illustrated in Figure <a href="reproj-geo-data.html#fig:crs-buf">7.2</a>.</p>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:crs-buf"></span>
<img src="figures/crs-buf-1.png" alt="Buffers around London showing results created with the S2 spherical geometry engine on lon/lat data (left), projected data (middle) and lon/lat data without using spherical geometry (right). The left plot illustrates the result of buffering unprojected data with sf, which calls Google's S2 spherical geometry engine by default with max cells set to 1000 (thin line). The thick, blocky line illustrates the result of the same operation with max cells set to 100." width="100%"><p class="caption">
FIGURE 7.2: Buffers around London showing results created with the S2 spherical geometry engine on lon/lat data (left), projected data (middle) and lon/lat data without using spherical geometry (right). The left plot illustrates the result of buffering unprojected data with sf, which calls Google’s S2 spherical geometry engine by default with max cells set to 1000 (thin line). The thick, blocky line illustrates the result of the same operation with max cells set to 100.
</p>
</div>
<p>It is clear from Figure <a href="reproj-geo-data.html#fig:crs-buf">7.2</a> that buffers based on <code>s2</code> and properly projected CRSs are not ‘squashed’, meaning that every part of the buffer boundary is equidistant to London.
The results that are generated from lon/lat CRSs when <code>s2</code> is <em>not</em> used, either because the input lacks a CRS or because <code><a href="https://r-spatial.github.io/sf/reference/s2.html">sf_use_s2()</a></code> is turned off, are heavily distorted, with the result elongated in the north-south axis, highlighting the dangers of using algorithms that assume projected data on lon/lat inputs (as GEOS does).
The results generated using S2 are also distorted, however, although less dramatically.
Both buffer boundaries in Figure <a href="reproj-geo-data.html#fig:crs-buf">7.2</a> (left) are jagged, although this may only be apparent or relevant for the thick boundary representing a buffer created with the <code>s2</code> argument <code>max_cells</code> set to 100.
The lesson is that results obtained from lon/lat data via S2 will be different from results obtained from using projected data.
The difference between S2 derived buffers and GEOS derived buffers on projected data reduce as the value of <code>max_cells</code> increases: the ‘right’ value for this argument may depend on many factors and the default value 1000 is often a reasonable default.
When choosing <code>max_cells</code> values, speed of computation should be balanced against resolution of results.
In situations where smooth curved boundaries are advantageous, transforming to a projected CRS before buffering (or performing other geometry operations) may be appropriate.</p>
<p>The importance of CRSs (primarily whether they are projected or geographic) and the impacts of <strong>sf</strong>’s default setting to use S2 for buffers on lon/lat data is clear from the example above.
The subsequent sections go into more depth, exploring which CRS to use when projected CRSs <em>are</em> needed and the details of reprojecting vector and raster objects.</p>
</div>
<div id="whenproject" class="section level2" number="7.5">
<h2>
<span class="header-section-number">7.5</span> When to reproject?<a class="anchor" aria-label="anchor" href="#whenproject"><i class="fas fa-link"></i></a>
</h2>
<p>
The previous section showed how to set the CRS manually, with <code>st_set_crs(london, "EPSG:4326")</code>.
In real-world applications, however, CRSs are usually set automatically when data is read-in.
In many projects the main CRS-related task is to <em>transform</em> objects, from one CRS into another.
But when should data be transformed?
And into which CRS?
There are no clear-cut answers to these questions and CRS selection always involves trade-offs <span class="citation">(<a href="references.html#ref-maling_coordinate_1992">Maling 1992</a>)</span>.
However, there are some general principles provided in this section that can help you decide.</p>
<p>First it’s worth considering <em>when to transform</em>.
In some cases transformation to a geographic CRS is essential, such as when publishing data online with the <strong>leaflet</strong> package.
Another case is when two objects with different CRSs must be compared or combined, as shown when we try to find the distance between two <code>sf</code> objects with different CRSs:</p>
<div class="sourceCode" id="cb238"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_distance</a></span><span class="op">(</span><span class="va">london_geo</span>, <span class="va">london_proj</span><span class="op">)</span></span>
<span><span class="co"># &gt; Error: st_crs(x) == st_crs(y) is not TRUE</span></span></code></pre></div>
<p>To make the <code>london</code> and <code>london_proj</code> objects geographically comparable, one of them must be transformed into the CRS of the other.
But which CRS to use?
The answer depends on context: many projects, especially those involving web mapping, require outputs in EPSG:4326, in which case it is worth transforming the projected object.
If, however, the project requires planar geometry operations rather than spherical geometry operations engine (e.g., to create buffers with smooth edges), it may be worth transforming data with a geographic CRS into an equivalent object with a projected CRS, such as the British National Grid (EPSG:27700).
That is the subject of Section <a href="reproj-geo-data.html#reproj-vec-geom">7.7</a>.</p>
</div>
<div id="which-crs" class="section level2" number="7.6">
<h2>
<span class="header-section-number">7.6</span> Which CRS to use?<a class="anchor" aria-label="anchor" href="#which-crs"><i class="fas fa-link"></i></a>
</h2>
<p>
The question of <em>which CRS to use</em> is tricky, and there is rarely a ‘right’ answer:
“There exist no all-purpose projections, all involve distortion when far from the center of the specified frame” <span class="citation">(<a href="references.html#ref-bivand_applied_2013">Bivand, Pebesma, and Gómez-Rubio 2013</a>)</span>.
Additionally, you should not be attached just to one projection for every task.
It is possible to use one projection for some part of the analysis, another projection for a different part, and even some other for visualization.
Always try to pick the CRS that serves your goal best!</p>
<p>When selecting <strong>geographic CRSs</strong>, the answer is often <a href="https://en.wikipedia.org/wiki/World_Geodetic_System#A_new_World_Geodetic_System:_WGS_84">WGS84</a>.
It is used not only for web mapping, but also because GPS datasets and thousands of raster and vector datasets are provided in this CRS by default.
WGS84 is the most common CRS in the world, so it is worth knowing its EPSG code: 4326.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Instead of &lt;code&gt;"EPSG:4326"&lt;/code&gt;, you may also use &lt;code&gt;"OGC:CRS84"&lt;/code&gt;. The former assumes that latitude is always ordered before longitude, while the latter is the standard representation used by GeoJSON, with coordinates ordered longitude before latitude.&lt;/p&gt;'><sup>32</sup></a>
This ‘magic number’ can be used to convert objects with unusual projected CRSs into something that is widely understood.</p>
<p>What about when a <strong>projected CRS</strong> is required?
In some cases, it is not something that we are free to decide:
“often the choice of projection is made by a public mapping agency” <span class="citation">(<a href="references.html#ref-bivand_applied_2013">Bivand, Pebesma, and Gómez-Rubio 2013</a>)</span>.
This means that when working with local data sources, it is likely preferable to work with the CRS in which the data was provided, to ensure compatibility, even if the official CRS is not the most accurate.
The example of London was easy to answer because (a) the British National Grid (with its associated EPSG code 27700) is well known and (b) the original dataset (<code>london</code>) already had that CRS.</p>
<p>
A commonly used default is Universal Transverse Mercator (<a href="https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system">UTM</a>), a set of CRSs that divides the Earth into 60 longitudinal wedges and 20 latitudinal segments.
Almost every place on Earth has a UTM code, such as “60H” which refers to northern New Zealand where R was invented.
UTM EPSG codes run sequentially from 32601 to 32660 for northern hemisphere locations and from 32701 to 32760 for southern hemisphere locations.</p>
<p>To show how the system works, let’s create a function, <code>lonlat2UTM()</code> to calculate the EPSG code associated with any point on the planet as <a href="https://stackoverflow.com/a/9188972/">follows</a>:</p>
<div class="sourceCode" id="cb239"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">lonlat2UTM</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">lonlat</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">utm</span> <span class="op">=</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Round.html">floor</a></span><span class="op">(</span><span class="op">(</span><span class="va">lonlat</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">180</span><span class="op">)</span> <span class="op">/</span> <span class="fl">6</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/Arithmetic.html">%%</a></span> <span class="fl">60</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span></span>
<span>  <span class="kw">if</span> <span class="op">(</span><span class="va">lonlat</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span> <span class="op">&gt;</span> <span class="fl">0</span><span class="op">)</span> <span class="op">{</span></span>
<span>    <span class="va">utm</span> <span class="op">+</span> <span class="fl">32600</span></span>
<span>  <span class="op">}</span> <span class="kw">else</span><span class="op">{</span></span>
<span>    <span class="va">utm</span> <span class="op">+</span> <span class="fl">32700</span></span>
<span>  <span class="op">}</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>The following command uses this function to identify the UTM zone and associated EPSG code for Auckland and London:</p>
<div class="sourceCode" id="cb240"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu">lonlat2UTM</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">174.7</span>, <span class="op">-</span><span class="fl">36.9</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 32760</span></span>
<span><span class="fu">lonlat2UTM</span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_coordinates.html">st_coordinates</a></span><span class="op">(</span><span class="va">london</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 32630</span></span></code></pre></div>
<p>The transverse Mercator projection used by UTM CRSs is conformal but distorts areas and distances with increasing severity with distance from the center of the UTM zone.
Documentation from the GIS software Manifold therefore suggests restricting the longitudinal extent of projects using UTM zones to 6 degrees from the central meridian (<a href="https://manifold.net/doc/mfd9/universal_transverse_mercator_projection.htm">manifold.net</a>).
Therefore, we recommend using UTM only when your focus is on preserving angles for a relatively small area!</p>
<p>Currently, we also have tools helping us to select a proper CRS, which includes the <strong>crsuggest</strong> package (<span class="citation">K. Walker (<a href="references.html#ref-R-crsuggest">2022</a>)</span>).
The main function in this package, <code>suggest_crs()</code>, takes a spatial object with geographic CRS and returns a list of possible projected CRSs that could be used for the given area.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;This package also allows to figure out the true CRS of the data without any CRS information attached.&lt;/p&gt;"><sup>33</sup></a>
Another helpful tool is the webpage <a href="https://jjimenezshaw.github.io/crs-explorer/" class="uri">https://jjimenezshaw.github.io/crs-explorer/</a> that lists CRSs based on selected location and type.
Important note: while these tools are helpful in many situations, you need to be aware of the properties of the recommended CRS before you apply it.</p>
<p>
In cases where an appropriate CRS is not immediately clear, the choice of CRS should depend on the properties that are most important to preserve in the subsequent maps and analysis.
CRSs are either equal-area, equidistant, conformal (with shapes remaining unchanged), or some combination of compromises of those (Section <a href="spatial-class.html#projected-coordinate-reference-systems">2.4.2</a>).
Custom CRSs with local parameters can be created for a region of interest and multiple CRSs can be used in projects when no single CRS suits all tasks.
‘Geodesic calculations’ can provide a fall-back if no CRSs are appropriate (see <a href="https://proj.org/geodesic.html">proj.org/geodesic.html</a>).
Regardless of the projected CRS used, the results may not be accurate for geometries covering hundreds of kilometers.</p>
<p>
When deciding on a custom CRS, we recommend the following:<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
Many thanks to an anonymous reviewer whose comments formed the basis of this advice.&lt;/p&gt;"><sup>34</sup></a></p>
<p>
</p>
<ul>
<li>A Lambert azimuthal equal-area (<a href="https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection">LAEA</a>) projection for a custom local projection (set latitude and longitude of origin to the center of the study area), which is an equal-area projection at all locations but distorts shapes beyond thousands of kilometers</li>
<li>Azimuthal equidistant (<a href="https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection">AEQD</a>) projections for a specifically accurate straight-line distance between a point and the center point of the local projection</li>
<li>Lambert conformal conic (<a href="https://en.wikipedia.org/wiki/Lambert_conformal_conic_projection">LCC</a>) projections for regions covering thousands of kilometers, with the cone set to keep distance and area properties reasonable between the secant lines</li>
<li>Stereographic (<a href="https://en.wikipedia.org/wiki/Stereographic_projection">STERE</a>) projections for polar regions, but taking care not to rely on area and distance calculations thousands of kilometers from the center</li>
</ul>
<p>One possible approach to automatically select a projected CRS specific to a local dataset is to create an <a href="https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection">AEQD</a> projection for the center-point of the study area.
This involves creating a custom CRS (with no EPSG code) with units of meters based on the center point of a dataset.
Note that this approach should be used with caution: no other datasets will be compatible with the custom CRS created, and results may not be accurate when used on extensive datasets covering hundreds of kilometers.</p>
<p>The principles outlined in this section apply equally to vector and raster datasets.
Some features of CRS transformation, however, are unique to each geographic data model.
We will cover the particularities of vector data transformation in Section <a href="reproj-geo-data.html#reproj-vec-geom">7.7</a> and those of raster transformation in Section <a href="reproj-geo-data.html#reproj-ras">7.8</a>.
Next, Section <a href="reproj-geo-data.html#mapproj">7.9</a>, shows how to create custom map projections.</p>
</div>
<div id="reproj-vec-geom" class="section level2" number="7.7">
<h2>
<span class="header-section-number">7.7</span> Reprojecting vector geometries<a class="anchor" aria-label="anchor" href="#reproj-vec-geom"><i class="fas fa-link"></i></a>
</h2>
<p>
Chapter <a href="spatial-class.html#spatial-class">2</a> demonstrated how vector geometries are made up of points, and how points form the basis of more complex objects such as lines and polygons.
Reprojecting vectors thus consists of transforming the coordinates of these points, which form the vertices of lines and polygons.</p>
<p>Section <a href="reproj-geo-data.html#whenproject">7.5</a> contains an example in which at least one <code>sf</code> object must be transformed into an equivalent object with a different CRS to calculate the distance between two objects.</p>
<div class="sourceCode" id="cb241"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">london2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">london_geo</span>, <span class="st">"EPSG:27700"</span><span class="op">)</span></span></code></pre></div>
<p>Now that a transformed version of <code>london</code> has been created, using the <strong>sf</strong> function <code><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform()</a></code>, the distance between the two representations of London can be found.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
An alternative to &lt;code&gt;st_transform()&lt;/code&gt; is &lt;code&gt;st_transform_proj()&lt;/code&gt; from the &lt;strong&gt;lwgeom&lt;/strong&gt;, which enables transformations and which bypasses GDAL and can support projections not supported by GDAL.
However, at the time of writing (2024) we could not find any projections supported by &lt;code&gt;st_transform_proj()&lt;/code&gt; but not supported by &lt;code&gt;st_transform()&lt;/code&gt;.&lt;/p&gt;"><sup>35</sup></a>
It may come as a surprise that <code>london</code> and <code>london2</code> are over 2 km apart!<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
The difference in location between the two points is not due to imperfections in the transforming operation (which is in fact very accurate) but the low precision of the manually-created coordinates that created &lt;code&gt;london&lt;/code&gt; and &lt;code&gt;london_proj&lt;/code&gt;.
Also surprising may be that the result is provided in a matrix with units of meters.
This is because &lt;code&gt;st_distance()&lt;/code&gt; can provide distances between many features and because the CRS has units of meters.
Use &lt;code&gt;as.numeric()&lt;/code&gt; to coerce the result into a regular number.&lt;/p&gt;"><sup>36</sup></a></p>
<div class="sourceCode" id="cb242"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_measures.html">st_distance</a></span><span class="op">(</span><span class="va">london2</span>, <span class="va">london_proj</span><span class="op">)</span></span>
<span><span class="co">#&gt; Units: [m]</span></span>
<span><span class="co">#&gt;      [,1]</span></span>
<span><span class="co">#&gt; [1,] 2018</span></span></code></pre></div>
<p>Functions for querying and reprojecting CRSs are demonstrated below with reference to <code>cycle_hire_osm</code>, an <code>sf</code> object from <strong>spData</strong> that represents ‘docking stations’ where you can hire bicycles in London.
The CRS of <code>sf</code> objects can be queried, and as we learned in Section <a href="reproj-geo-data.html#reproj-intro">7.1</a>, set with the function <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code>.
The output is printed as multiple lines of text containing information about the coordinate system:</p>
<div class="sourceCode" id="cb243"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">cycle_hire_osm</span><span class="op">)</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: EPSG:4326 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt; GEOGCS["WGS 84",</span></span>
<span><span class="co">#&gt;     DATUM["WGS_1984",</span></span>
<span><span class="co">#&gt;         SPHEROID["WGS 84",6378137,298.257223563,</span></span>
<span><span class="va">....</span></span></code></pre></div>
<p>As we saw in Section <a href="reproj-geo-data.html#crs-setting">7.3</a>, the main CRS components, <code>User input</code> and <code>wkt</code>, are printed as a single entity. The output of <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code> is in fact a named list of class <code>crs</code> with two elements, single character strings named <code>input</code> and <code>wkt</code>, as shown in the output of the following code chunk:</p>
<div class="sourceCode" id="cb244"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">crs_lnd</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">london_geo</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">crs_lnd</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "crs"</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/names.html">names</a></span><span class="op">(</span><span class="va">crs_lnd</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "input" "wkt"</span></span></code></pre></div>
<p>Additional elements can be retrieved with the <code>$</code> operator, including <code>Name</code>, <code>proj4string</code> and <code>epsg</code> (see <a href="https://r-spatial.github.io/sf/reference/st_crs.html"><code>?st_crs</code></a> and the CRS and tranformation tutorial on the GDAL <a href="https://gdal.org/tutorials/osr_api_tut.html#querying-coordinate-reference-system">website</a> for details):</p>
<div class="sourceCode" id="cb245"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">crs_lnd</span><span class="op">$</span><span class="va">Name</span></span>
<span><span class="co">#&gt; [1] "WGS 84"</span></span>
<span><span class="va">crs_lnd</span><span class="op">$</span><span class="va">proj4string</span></span>
<span><span class="co">#&gt; [1] "+proj=longlat +datum=WGS84 +no_defs"</span></span>
<span><span class="va">crs_lnd</span><span class="op">$</span><span class="va">epsg</span></span>
<span><span class="co">#&gt; [1] 4326</span></span></code></pre></div>
<p>As mentioned in Section <a href="reproj-geo-data.html#crs-in-r">7.2</a>, WKT representation, stored in the <code>$wkt</code> element of the <code>crs_lnd</code> object is the ultimate source of truth.
This means that the outputs of the previous code chunk are queries from the <code>wkt</code> representation provided by PROJ, rather than inherent attributes of the object and its CRS.</p>
<p>Both <code>wkt</code> and <code>User Input</code> elements of the CRS are changed when the object’s CRS is transformed.
In the code chunk below, we create a new version of <code>cycle_hire_osm</code> with a projected CRS (only the first 4 lines of the CRS output are shown for brevity).</p>
<div class="sourceCode" id="cb246"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cycle_hire_osm_projected</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">cycle_hire_osm</span>, <span class="st">"EPSG:27700"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs</a></span><span class="op">(</span><span class="va">cycle_hire_osm_projected</span><span class="op">)</span></span>
<span><span class="co">#&gt; Coordinate Reference System:</span></span>
<span><span class="co">#&gt;   User input: EPSG:27700 </span></span>
<span><span class="co">#&gt;   wkt:</span></span>
<span><span class="co">#&gt; PROJCRS["OSGB36 / British National Grid",</span></span>
<span><span class="co">#&gt; ...</span></span></code></pre></div>
<p>The resulting object has a new CRS with an EPSG code 27700.
But how do we find out more details about this EPSG code, or any code?
One option is to search for it online, another is to look at the properties of the CRS object:</p>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb247-1"><a href="reproj-geo-data.html#cb247-1" tabindex="-1"></a>crs_lnd_new <span class="ot">=</span> <span class="fu">st_crs</span>(<span class="st">"EPSG:27700"</span>)</span>
<span id="cb247-2"><a href="reproj-geo-data.html#cb247-2" tabindex="-1"></a>crs_lnd_new<span class="sc">$</span>Name</span>
<span id="cb247-3"><a href="reproj-geo-data.html#cb247-3" tabindex="-1"></a><span class="co">#&gt; [1] "OSGB36 / British National Grid"</span></span>
<span id="cb247-4"><a href="reproj-geo-data.html#cb247-4" tabindex="-1"></a>crs_lnd_new<span class="sc">$</span>proj4string</span>
<span id="cb247-5"><a href="reproj-geo-data.html#cb247-5" tabindex="-1"></a><span class="co">#&gt; [1] "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000</span></span>
<span id="cb247-6"><a href="reproj-geo-data.html#cb247-6" tabindex="-1"></a><span class="sc">+</span>y_0<span class="ot">=</span><span class="sc">-</span><span class="dv">100000</span> <span class="sc">+</span>ellps<span class="ot">=</span>airy <span class="sc">+</span>units<span class="ot">=</span>m <span class="sc">+</span>no_defs<span class="st">"</span></span>
<span id="cb247-7"><a href="reproj-geo-data.html#cb247-7" tabindex="-1"></a><span class="st">crs_lnd_new$epsg</span></span>
<span id="cb247-8"><a href="reproj-geo-data.html#cb247-8" tabindex="-1"></a><span class="st">#&gt; [1] 27700</span></span></code></pre></div>
<p>The result shows that the EPSG code 27700 represents the British National Grid, which could have been found by searching online for “<a href="https://www.google.com/search?q=CRS+27700">EPSG 27700</a>”.</p>

<div class="rmdnote">
Printing a spatial object in the console automatically returns its coordinate reference system.
To access and modify it explicitly, use the <code>st_crs</code> function, for example, <code>st_crs(cycle_hire_osm)</code>.
</div>
</div>
<div id="reproj-ras" class="section level2" number="7.8">
<h2>
<span class="header-section-number">7.8</span> Reprojecting raster geometries<a class="anchor" aria-label="anchor" href="#reproj-ras"><i class="fas fa-link"></i></a>
</h2>
<p>
The projection concepts described in the previous section apply to rasters.
However, there are important differences in reprojection of vectors and rasters:
transforming a vector object involves changing the coordinates of every vertex, but this does not apply to raster data.
Rasters are composed of rectangular cells of the same size (expressed by map units, such as degrees or meters), so it is usually impracticable to transform coordinates of pixels separately.
Thus, raster reprojection involves creating a new raster object, often with a different number of columns and rows than the original.
The attributes must subsequently be re-estimated, allowing the new pixels to be ‘filled’ with appropriate values.
In other words, raster reprojection can be thought of as two separate spatial operations: a vector reprojection of the raster extent to another CRS (Section <a href="reproj-geo-data.html#reproj-vec-geom">7.7</a>), and computation of new pixel values through resampling (Section <a href="geometry-operations.html#resampling">5.3.4</a>).
Thus in most cases when both raster and vector data are used, it is better to avoid reprojecting rasters and to reproject vectors instead.</p>

<div class="rmdnote">
Reprojection of the regular rasters is also known as warping.
Additionally, there is a second similar operation called “transformation”.
Instead of resampling all of the values, it leaves all values intact but recomputes new coordinates for every raster cell, changing the grid geometry.
For example, it could convert the input raster (a regular grid) into a curvilinear grid.
The transformation operation can be performed in R using <a href="https://r-spatial.github.io/stars/articles/stars5.html">the <strong>stars</strong> package</a>.
</div>
<p>The raster reprojection process is done with <code><a href="https://rspatial.github.io/terra/reference/project.html">project()</a></code> from the <strong>terra</strong> package.
Like the <code><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform()</a></code> function demonstrated in the previous section, <code><a href="https://rspatial.github.io/terra/reference/project.html">project()</a></code> takes a spatial object (a raster dataset in this case) and some CRS representation as the second argument.
On a side note, the second argument can also be an existing raster object with a different CRS.</p>
<p>Let’s take a look at two examples of raster transformation: using categorical and continuous data.
Land cover data are usually represented by categorical maps.
The <code>nlcd.tif</code> file provides information for a small area in Utah, USA obtained from <a href="https://www.mrlc.gov/data/nlcd-2011-land-cover-conus">National Land Cover Database 2011</a> in the NAD83 / UTM zone 12N CRS, as shown in the output of the code chunk below (only first line of output shown).</p>
<div class="sourceCode" id="cb248"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cat_raster</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/nlcd.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">cat_raster</span><span class="op">)</span></span>
<span><span class="co">#&gt; PROJCRS["NAD83 / UTM zone 12N",</span></span>
<span><span class="co">#&gt; ...</span></span></code></pre></div>
<p>In this region, eight land cover classes were distinguished (a full list of NLCD2011 land cover classes can be found at <a href="https://www.mrlc.gov/data/legends/national-land-cover-database-2011-nlcd2011-legend">mrlc.gov</a>):</p>
<div class="sourceCode" id="cb249"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rspatial.github.io/terra/reference/unique.html">unique</a></span><span class="op">(</span><span class="va">cat_raster</span><span class="op">)</span></span>
<span><span class="co">#&gt;       levels</span></span>
<span><span class="co">#&gt; 1      Water</span></span>
<span><span class="co">#&gt; 2  Developed</span></span>
<span><span class="co">#&gt; 3     Barren</span></span>
<span><span class="co">#&gt; 4     Forest</span></span>
<span><span class="co">#&gt; 5  Shrubland</span></span>
<span><span class="co">#&gt; 6 Herbaceous</span></span>
<span><span class="co">#&gt; 7 Cultivated</span></span>
<span><span class="co">#&gt; 8   Wetlands</span></span></code></pre></div>
<p>When reprojecting categorical rasters, the estimated values must be the same as those of the original.
This could be done using the nearest neighbor method (<code>near</code>), which sets each new cell value to the value of the nearest cell (center) of the input raster.
An example is reprojecting <code>cat_raster</code> to WGS84, a geographic CRS well suited for web mapping.
The first step is to obtain the definition of this CRS.
The second step is to reproject the raster with the <code><a href="https://rspatial.github.io/terra/reference/project.html">project()</a></code> function which, in the case of categorical data, uses the nearest neighbor method (<code>near</code>).</p>
<div class="sourceCode" id="cb250"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cat_raster_wgs84</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/project.html">project</a></span><span class="op">(</span><span class="va">cat_raster</span>, <span class="st">"EPSG:4326"</span>, method <span class="op">=</span> <span class="st">"near"</span><span class="op">)</span></span></code></pre></div>
<p>Many properties of the new object differ from the previous one, including the number of columns and rows (and therefore number of cells), resolution (transformed from meters into degrees), and extent, as illustrated in Table <a href="reproj-geo-data.html#tab:catraster">7.1</a> (note that the number of categories increases from 8 to 9 because of the addition of <code>NA</code> values, not because a new category has been created — the land cover classes are preserved).</p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:catraster">TABLE 7.1: </span>Key attributes in the original (cat_raster) and projected (cat_raster_wgs84) categorical raster datasets.</caption>
<thead><tr class="header">
<th align="left">CRS</th>
<th align="right">nrow</th>
<th align="right">ncol</th>
<th align="right">ncell</th>
<th align="right">resolution</th>
<th align="right">unique_categories</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">NAD83</td>
<td align="right">1359</td>
<td align="right">1073</td>
<td align="right">1458207</td>
<td align="right">31.5275</td>
<td align="right">8</td>
</tr>
<tr class="even">
<td align="left">WGS84</td>
<td align="right">1246</td>
<td align="right">1244</td>
<td align="right">1550024</td>
<td align="right">0.0003</td>
<td align="right">9</td>
</tr>
</tbody>
</table></div>
<p>Reprojecting numeric rasters (with <code>numeric</code> or in this case <code>integer</code> values) follows an almost identical procedure.
This is demonstrated below with <code>srtm.tif</code> in <strong>spDataLarge</strong> from <a href="https://www2.jpl.nasa.gov/srtm/">the Shuttle Radar Topography Mission (SRTM)</a>, which represents height in meters above sea level (elevation) with the WGS84 CRS:</p>
<div class="sourceCode" id="cb251"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">con_raster</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/rast.html">rast</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"raster/srtm.tif"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">con_raster</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; GEOGCRS["WGS 84",</span></span>
<span><span class="co">#&gt;     ENSEMBLE["World Geodetic System 1984 ensemble",</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (Transit)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G730)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G873)"],</span></span>
<span><span class="co">#&gt;         MEMBER["World Geodetic System 1984 (G1150)"],</span></span>
<span><span class="va">....</span></span></code></pre></div>
<p>We will reproject this dataset into a projected CRS, but <em>not</em> with the nearest neighbor method which is appropriate for categorical data.
Instead, we will use the bilinear method which computes the output cell value based on the four nearest cells in the original raster.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Other methods mentioned in Section &lt;a href="geometry-operations.html#resampling"&gt;5.3.4&lt;/a&gt; also can be used here.&lt;/p&gt;'><sup>37</sup></a>
The values in the projected dataset are the distance-weighted average of the values from these four cells:
the closer the input cell is to the center of the output cell, the greater its weight.
The following commands create a text string representing WGS 84 / UTM zone 12N, and reproject the raster into this CRS, using the <code>bilinear</code> method (output not shown).</p>
<div class="sourceCode" id="cb252"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">con_raster_ea</span> <span class="op">=</span> <span class="fu"><a href="https://rspatial.github.io/terra/reference/project.html">project</a></span><span class="op">(</span><span class="va">con_raster</span>, <span class="st">"EPSG:32612"</span>, method <span class="op">=</span> <span class="st">"bilinear"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="fu"><a href="https://rspatial.github.io/terra/reference/crs.html">crs</a></span><span class="op">(</span><span class="va">con_raster_ea</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Raster reprojection on numeric variables also leads to changes to values and spatial properties, such as the number of cells, resolution, and extent.
These changes are demonstrated in Table <a href="reproj-geo-data.html#tab:rastercrs">7.2</a>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content='&lt;p&gt;
Another minor change, which is not represented in Table &lt;a href="reproj-geo-data.html#tab:rastercrs"&gt;7.2&lt;/a&gt;, is that the class of the values in the new projected raster dataset is &lt;code&gt;numeric&lt;/code&gt;.
This is because the &lt;code&gt;bilinear&lt;/code&gt; method works with continuous data and the results are rarely coerced into whole integer values.
This can have implications for file sizes when raster datasets are saved.&lt;/p&gt;'><sup>38</sup></a></p>
<div class="inline-table"><table class="table table-sm">
<caption>
<span id="tab:rastercrs">TABLE 7.2: </span>Key attributes in the original (con_raster) and projected (con_raster_ea) continuous raster datasets.</caption>
<thead><tr class="header">
<th align="left">CRS</th>
<th align="right">nrow</th>
<th align="right">ncol</th>
<th align="right">ncell</th>
<th align="right">resolution</th>
<th align="right">mean</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">WGS84</td>
<td align="right">457</td>
<td align="right">465</td>
<td align="right">212505</td>
<td align="right">0.0008</td>
<td align="right">1843</td>
</tr>
<tr class="even">
<td align="left">UTM zone 12N</td>
<td align="right">515</td>
<td align="right">422</td>
<td align="right">217330</td>
<td align="right">83.5334</td>
<td align="right">1842</td>
</tr>
</tbody>
</table></div>
<div class="rmdnote">
Of course, the limitations of 2D Earth projections apply as much to vector as to raster data.
At best we can comply with two out of three spatial properties (distance, area, direction).
Therefore, the task at hand determines which projection to choose.
For instance, if we are interested in a density (points per grid cell or inhabitants per grid cell), we should use an equal-area projection (see also Chapter <a href="location.html#location">14</a>).
</div>
</div>
<div id="mapproj" class="section level2" number="7.9">
<h2>
<span class="header-section-number">7.9</span> Custom map projections<a class="anchor" aria-label="anchor" href="#mapproj"><i class="fas fa-link"></i></a>
</h2>
<p>
Established CRSs captured by <code>AUTHORITY:CODE</code> identifiers such as <code>EPSG:4326</code> are well suited for many applications.
However, it is desirable to use alternative projections or to create custom CRSs in some cases.
Section <a href="reproj-geo-data.html#which-crs">7.6</a> mentioned reasons for using custom CRSs and provided several possible approaches.
Here, we show how to apply these ideas in R.</p>
<p>One is to take an existing WKT definition of a CRS, modify some of its elements, and then use the new definition for reprojecting.
This can be done for spatial vectors with <code><a href="https://r-spatial.github.io/sf/reference/st_crs.html">st_crs()</a></code> and <code><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform()</a></code>, and for spatial rasters with <code><a href="https://rspatial.github.io/terra/reference/crs.html">crs()</a></code> and <code><a href="https://rspatial.github.io/terra/reference/project.html">project()</a></code>, as demonstrated in the following example which transforms the <code>zion</code> object to a custom azimuthal equidistant (AEQD) CRS.</p>
<div class="sourceCode" id="cb253"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_read.html">read_sf</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span><span class="op">(</span><span class="st">"vector/zion.gpkg"</span>, package <span class="op">=</span> <span class="st">"spDataLarge"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Using a custom AEQD CRS requires knowing the coordinates of the center point of a dataset in degrees (geographic CRS).
In our case, this information can be extracted by calculating a centroid of the <code>zion</code> area and transforming it into WGS84.</p>
<div class="sourceCode" id="cb254"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_centr</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/geos_unary.html">st_centroid</a></span><span class="op">(</span><span class="va">zion</span><span class="op">)</span></span>
<span><span class="va">zion_centr_wgs84</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">zion_centr</span>, <span class="st">"EPSG:4326"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_as_text.html">st_as_text</a></span><span class="op">(</span><span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_geometry.html">st_geometry</a></span><span class="op">(</span><span class="va">zion_centr_wgs84</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "POINT (-113 37.3)"</span></span></code></pre></div>
<p>Next, we can use the newly obtained values to update the WKT definition of the AEQD CRS seen below.
Notice that we modified just two values below – <code>"Central_Meridian"</code> to the longitude and <code>"Latitude_Of_Origin"</code> to the latitude of our centroid.</p>
<div class="sourceCode" id="cb255"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">my_wkt</span> <span class="op">=</span> <span class="st">'PROJCS["Custom_AEQD",</span></span>
<span><span class="st"> GEOGCS["GCS_WGS_1984",</span></span>
<span><span class="st">  DATUM["WGS_1984",</span></span>
<span><span class="st">   SPHEROID["WGS_1984",6378137.0,298.257223563]],</span></span>
<span><span class="st">  PRIMEM["Greenwich",0.0],</span></span>
<span><span class="st">  UNIT["Degree",0.0174532925199433]],</span></span>
<span><span class="st"> PROJECTION["Azimuthal_Equidistant"],</span></span>
<span><span class="st"> PARAMETER["Central_Meridian",-113.0263],</span></span>
<span><span class="st"> PARAMETER["Latitude_Of_Origin",37.29818],</span></span>
<span><span class="st"> UNIT["Meter",1.0]]'</span></span></code></pre></div>
<p>This approach’s last step is to transform our original object (<code>zion</code>) to our new custom CRS (<code>zion_aeqd</code>).</p>
<div class="sourceCode" id="cb256"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">zion_aeqd</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">zion</span>, <span class="va">my_wkt</span><span class="op">)</span></span></code></pre></div>
<p>Custom projections can also be made interactively, for example, using the <a href="https://projectionwizard.org/#">Projection Wizard</a> web application <span class="citation">(<a href="references.html#ref-savric_projection_2016">Šavrič, Jenny, and Jenny 2016</a>)</span>.
This website allows you to select a spatial extent of your data and a distortion property, and returns a list of possible projections.
The list also contains WKT definitions of the projections that you can copy and use for reprojections.
Also, see <span class="citation">Open Geospatial Consortium (<a href="references.html#ref-opengeospatialconsortium_wellknown_2019">2019</a>)</span> for details on creating custom CRS definitions with WKT strings.</p>
<p>
PROJ strings can also be used to create custom projections, accepting the limitations inherent to projections, especially of geometries covering large geographic areas, mentioned in Section <a href="reproj-geo-data.html#crs-in-r">7.2</a>.
Many projections have been developed and can be set with the <code>+proj=</code> element of PROJ strings, with dozens of projects described in detail on the <a href="https://proj.org/operations/projections/index.html">PROJ website</a> alone.</p>
<p>When mapping the world while preserving area relationships, the Mollweide projection, illustrated in Figure <a href="reproj-geo-data.html#fig:mollproj">7.3</a>, is a popular and often sensible choice <span class="citation">(<a href="references.html#ref-jenny_guide_2017">Jenny et al. 2017</a>)</span>.
To use this projection, we need to specify it using the proj-string element, <code>"+proj=moll"</code>, in the <code>st_transform</code> function:</p>
<div class="sourceCode" id="cb257"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">world_mollweide</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">world</span>, crs <span class="op">=</span> <span class="st">"+proj=moll"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:mollproj"></span>
<img src="figures/mollproj-1.png" alt="Mollweide projection of the world." width="100%"><p class="caption">
FIGURE 7.3: Mollweide projection of the world.
</p>
</div>
<p>It is often desirable to minimize distortion for all spatial properties (area, direction, distance) when mapping the world.
One of the most popular projections to achieve this is <a href="https://www.winkel.org/other/Winkel%20Tripel%20Projections.htm">Winkel tripel</a>, illustrated in Figure <a href="reproj-geo-data.html#fig:wintriproj">7.4</a>.<a class="footnote-ref" tabindex="0" data-toggle="popover" data-content="&lt;p&gt;
This projection is used, among others, by the National Geographic Society.&lt;/p&gt;"><sup>39</sup></a>
The result was created with the following command:</p>
<div class="sourceCode" id="cb258"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">world_wintri</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">world</span>, crs <span class="op">=</span> <span class="st">"+proj=wintri"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:wintriproj"></span>
<img src="figures/wintriproj-1.png" alt="Winkel tripel projection of the world." width="100%"><p class="caption">
FIGURE 7.4: Winkel tripel projection of the world.
</p>
</div>
<p>Moreover, proj-string parameters can be modified in most CRS definitions, for example the center of the projection can be adjusted using the <code>+lon_0</code> and <code>+lat_0</code> parameters.
The below code transforms the coordinates to the Lambert azimuthal equal-area projection centered on the longitude and latitude of New York City (Figure <a href="reproj-geo-data.html#fig:laeaproj2">7.5</a>).</p>
<div class="sourceCode" id="cb259"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">world_laea2</span> <span class="op">=</span> <span class="fu"><a href="https://r-spatial.github.io/sf/reference/st_transform.html">st_transform</a></span><span class="op">(</span><span class="va">world</span>,</span>
<span>                           crs <span class="op">=</span> <span class="st">"+proj=laea +x_0=0 +y_0=0 +lon_0=-74 +lat_0=40"</span><span class="op">)</span></span></code></pre></div>
<div class="figure" style="text-align: center">
<span style="display:block;" id="fig:laeaproj2"></span>
<img src="figures/laeaproj2-1.png" alt="Lambert azimuthal equal-area projection of the world centered on New York City." width="100%"><p class="caption">
FIGURE 7.5: Lambert azimuthal equal-area projection of the world centered on New York City.
</p>
</div>
<p>More information on CRS modifications can be found in the <a href="https://proj.org/usage/index.html">Using PROJ</a> documentation.</p>
</div>
<div id="exercises-5" class="section level2" number="7.10">
<h2>
<span class="header-section-number">7.10</span> Exercises<a class="anchor" aria-label="anchor" href="#exercises-5"><i class="fas fa-link"></i></a>
</h2>
<p>E1. Create a new object called <code>nz_wgs</code> by transforming <code>nz</code> object into the WGS84 CRS.</p>
<ul>
<li>Create an object of class <code>crs</code> for both and use this to query their CRSs.</li>
<li>With reference to the bounding box of each object, what units does each CRS use?</li>
<li>Remove the CRS from <code>nz_wgs</code> and plot the result: what is wrong with this map of New Zealand and why?</li>
</ul>
<p>E2. Transform the <code>world</code> dataset to the transverse Mercator projection (<code>"+proj=tmerc"</code>) and plot the result.
What has changed and why?
Try to transform it back into WGS 84 and plot the new object.
Why does the new object differ from the original one?</p>
<p>E3. Transform the continuous raster (<code>con_raster</code>) into NAD83 / UTM zone 12N using the nearest neighbor interpolation method.
What has changed?
How does it influence the results?</p>
<p>E4. Transform the categorical raster (<code>cat_raster</code>) into WGS 84 using the bilinear interpolation method.
What has changed?
How does it influence the results?</p>
<!--toDo:jn-->
<!--improve/replace/modify the following q-->
<!-- E5. Create your own proj-string.  -->
<!-- It should have the Lambert Azimuthal Equal Area (`laea`) projection, the WGS84 ellipsoid, the longitude of projection center of 95 degrees west, the latitude of projection center of 60 degrees north, and its units should be in meters. -->
<!-- Next, subset Canada from the `world` object and transform it into the new projection.  -->
<!-- Plot and compare a map before and after the transformation. -->
<!-- ```{r 06-reproj-40} -->
<!-- new_p4s = "+proj=laea +ellps=WGS84 +lon_0=-95 +lat_0=60 +units=m" -->
<!-- canada = dplyr::filter(world, name_long == "Canada") -->
<!-- new_canada = st_transform(canada, new_p4s) -->
<!-- par(mfrow = c(1, 2)) -->
<!-- plot(st_geometry(canada), graticule = TRUE, axes = TRUE) -->
<!-- plot(st_geometry(new_canada), graticule = TRUE, axes = TRUE) -->
<!-- ``` -->

</div>
</div>

  <div class="chapter-nav">
<div class="prev"><a href="raster-vector.html"><span class="header-section-number">6</span> Raster-vector interactions</a></div>
<div class="next"><a href="read-write.html"><span class="header-section-number">8</span> Geographic data I/O</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <h2>Second Edition</h2>
    <!--<p>Now is a great time to provide feedback</p>-->
        <ul class="list-unstyled">
<!--<li><a href="https://forms.gle/nq9RmbxJyZXQgc948">Provide feedback (5 min)</a></li>--><li><a href="https://geocompx.org/">Visit the geocompx website 🌐</a></li>
          <li><a href="https://r.geocompx.org/#reproducibility">Install updated packages 💾</a></li>
          <li><a href="https://github.com/geocompx/geocompr/issues">Open an issue <i class="fas fa-question"></i></a></li>
          <li><a href="https://discord.gg/PMztXYgNxp">Chat on Discord <i class="fab fa-discord"></i></a></li>
          <li><a href="https://r.geocompx.org/solutions/">Check exercise solutions <i class="fa fa-check"></i></a></li>
          <li><a href="https://supportukrainenow.org/">Support Ukraine 🇺🇦</a></li>
          <li><a href="https://donate.stripe.com/4gweWl94Q9E35AQ6oo">Support this project 💸</a></li>
        </ul>
<hr>
<nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#reproj-geo-data"><span class="header-section-number">7</span> Reprojecting geographic data</a></li>
<li><a class="nav-link" href="#prerequisites-5">Prerequisites</a></li>
<li><a class="nav-link" href="#reproj-intro"><span class="header-section-number">7.1</span> Introduction</a></li>
<li><a class="nav-link" href="#crs-in-r"><span class="header-section-number">7.2</span> Coordinate reference systems</a></li>
<li><a class="nav-link" href="#crs-setting"><span class="header-section-number">7.3</span> Querying and setting coordinate systems</a></li>
<li><a class="nav-link" href="#geom-proj"><span class="header-section-number">7.4</span> Geometry operations on projected and unprojected data</a></li>
<li><a class="nav-link" href="#whenproject"><span class="header-section-number">7.5</span> When to reproject?</a></li>
<li><a class="nav-link" href="#which-crs"><span class="header-section-number">7.6</span> Which CRS to use?</a></li>
<li><a class="nav-link" href="#reproj-vec-geom"><span class="header-section-number">7.7</span> Reprojecting vector geometries</a></li>
<li><a class="nav-link" href="#reproj-ras"><span class="header-section-number">7.8</span> Reprojecting raster geometries</a></li>
<li><a class="nav-link" href="#mapproj"><span class="header-section-number">7.9</span> Custom map projections</a></li>
<li><a class="nav-link" href="#exercises-5"><span class="header-section-number">7.10</span> Exercises</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/geocompx/geocompr/blob/main/07-reproj.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/geocompx/geocompr/edit/main/07-reproj.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>Geocomputation with R</strong>" was written by Robin Lovelace, Jakub Nowosad, Jannes Muenchow. It was last built on 2025-06-17.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
